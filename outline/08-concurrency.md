# 第八章：对抗“无序”：驯服并发访问的猛兽

> "世界上唯一不变的，是变化本身。" - 赫拉克利特

*   **本章危机**: 我们的API上线了，但很快就崩溃了。当两个用户“同时”尝试修改同一个播放列表文件时，我们的数据被写坏了（产生了“竞态条件”）。我们引以为傲的、基于文件的持久化方案，在“并发”这头猛兽面前，不堪一击。
*   **本章顿悟**: 文件系统本质上是一个“悲观锁”的、低效的并发模型。我们需要一个专业的、从诞生之初就是为了解决“并发数据访问”而设计的系统。这个系统，就是“关系型数据库”。

---
## 本章结构

*   **`01-why-database.qmd`: 为何需要数据库？ACID的四大守护**
    *   **内容描述**: 本节将从第一性原理出发，深入剖析文件存储在处理并发写入、数据一致性、复杂查询和事务时的根本性缺陷。我们将揭示关系型数据库（RDBMS）的本质——它是一个提供了**ACID**（原子性、一致性、隔离性、持久性）保证的**结构化数据存储引擎**。我们将逐一理解这四个特性如何成为它驯服并发猛兽的“四大守护神”，以及它们在实际应用中如何确保数据的完整性和可靠性。
    *   **Vibe Check (思考与练习)**:
        1.  **思考**: 想象一个银行转账的场景：从A账户扣款，向B账户加款。如果这个操作不是“原子性”的，会发生什么灾难？如果不是“一致性”的，又会怎样？
        2.  **AI协同**: 询问你的AI伙伴：“请用一个简单的例子，解释数据库事务的‘隔离性’（Isolation）是如何防止并发操作导致数据混乱的。例如，两个用户同时修改同一条记录。”
        3.  **案例分析**: 除了银行系统，你还能想到哪些日常应用对数据的ACID特性有严格要求？为什么？

*   **`02-why-orm.qmd`: 为何需要ORM？跨越对象与关系的鸿沟**
    *   **内容描述**: Java代码操作的是“对象图”（由相互关联的对象组成），而关系型数据库存储的是“二维表”（由行和列组成）。这两种模型之间存在天然的“阻抗不匹配”。本节将论证ORM（对象关系映射）的本质——它是一个“**翻译层**”，它让我们能用符合面向对象思维的方式（操作Java对象），来操作关系型数据（数据库表），从而极大地提高了开发效率，并减少了直接编写SQL的复杂性和潜在错误。
    *   **Vibe Check (思考与练习)**:
        1.  **思考**: 如果没有ORM，你需要手动编写哪些代码来将一个Java `Song`对象保存到数据库的`songs`表中？反过来，从数据库中读取数据后，又需要哪些步骤才能将其转换为Java `Song`对象？
        2.  **AI协同**: 询问AI：“请解释一下‘对象关系阻抗不匹配’（Object-Relational Impedance Mismatch）具体指的是什么？它主要体现在哪些方面？”
        3.  **权衡**: ORM虽然方便，但它也有其缺点，例如可能生成低效的SQL。你认为在什么情况下，直接编写SQL会比使用ORM更有优势？

*   **`03-database-migration.qmd`: 迁移到PostgreSQL**
    *   **内容描述**: 在理解了数据库和ORM的“为什么”之后，本节将进入“怎么做”。我们将把我们的`Repository`层，从之前的文件I/O实现，彻底改造为使用Spring Data JPA与PostgreSQL数据库对话。我们将学习如何配置Spring Boot来连接PostgreSQL，如何使用JPA注解（如`@Entity`, `@Id`, `@GeneratedValue`）来定义我们的实体类，以及如何利用Spring Data JPA的强大功能（如自动生成CRUD方法）来简化数据访问层的开发。
    *   **Vibe Check (思考与练习)**:
        1.  **核心练习**: 按照教程步骤，成功配置Spring Boot连接PostgreSQL，并定义你的第一个JPA实体（例如`Song`）。运行应用，观察Spring Boot是否自动创建了对应的数据库表。
        2.  **编码练习**: 使用Spring Data JPA的`JpaRepository`接口，为你的`Song`实体创建一个Repository。然后，在你的`PlaylistService`中注入这个Repository，并修改`addSong`、`removeSong`、`listSongs`等方法，使其通过Repository与数据库交互。
        3.  **破坏性实验**: 故意修改你的实体类中的一个字段名，但不同步修改数据库表中的列名。运行应用，观察Spring Boot会抛出什么异常？这如何体现了JPA在对象与关系映射上的严格性？
        4.  **AI协同与扩展**: 询问AI：“请解释Spring Data JPA中的‘派生查询方法’（Derived Query Methods）是什么？请为我生成一个根据歌曲标题模糊查询歌曲的Repository方法签名。”
