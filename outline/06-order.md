# 第六章：对抗“混沌”：当代码变成一团乱麻

> "简单，是最终的复杂。" - 列奥纳多·达·芬奇

*   **本章危机**: 随着功能增多（UI交互逻辑、数据读写逻辑、核心业务规则），我们所有的代码都挤在几个文件里（`Main.java`, `Playlist.java`）。修改一个地方，可能会意外地影响到另一个看似无关的地方。代码的“熵”在不断增加，我们正不可避免地滑向“混沌”的深渊。
*   **本章顿悟**: 对抗软件混沌的唯一武器，就是“秩序”。我们需要引入一种架构，为不同职责的代码，划分出清晰的“边界”和“领地”。这个架构，就是“关注点分离”。

---
## 本章结构

*   **`01-why-architecture.qmd`: 为何需要架构？对抗软件的熵增**
    *   **内容描述**: 本节将探讨一个深刻的问题：为什么软件总是倾向于变得越来越复杂和混乱？我们将引入“熵增定律”作为理解这一现象的思维模型。我们将从第一性原理出发，论证软件架构的本质——**它是一系列精心设计的“约束”，其唯一目的，就是主动地、持续地对抗熵增**。一个好的架构，能让系统在不断变化的需求中，依然保持清晰、可理解和易于修改，从而延长其生命周期。
    *   **Vibe Check (思考与练习)**:
        1.  **思考**: 在你的房间里，如果你不主动花精力去整理（施加“秩序”），它会自然地变得越来越整齐，还是越来越混乱？软件代码也是一样吗？为什么？
        2.  **AI协同**: "请向我解释‘高内聚、低耦合’（High Cohesion, Low Coupling）这两个软件设计的基本原则。它们是如何帮助我们对抗‘熵增’的？"
        3.  **案例分析**: 回顾我们目前的代码，你能指出哪些地方体现了“低内聚”（例如，一个类做了太多不相干的事）或“高耦合”（例如，`Main`类直接了解文件读写的细节）吗？

*   **`02-separation-of-concerns.qmd`: 关注点分离：三层架构**
    *   **内容描述**: 在理解了“为何需要架构”后，我们将学习一种最经典、最实用、也是所有更复杂架构基础的架构模式——**分层架构**。我们将把我们的应用，按照“关注点”的不同，清晰地划分为三个层次：
        *   **表现层 (UI/Controller)**: 只负责与用户交互，翻译用户的输入输出。
        *   **业务逻辑层 (Service)**: 只负责核心业务规则，不关心数据从哪来，也不关心结果给谁看。
        *   **数据访问层 (Repository)**: 只负责数据的读取和存储，不关心业务规则。
        我们将为每一层定义清晰的接口（Interface），作为它们之间沟通的“契约”。
    *   **Vibe Check (思考与练习)**:
        1.  **核心练习**: 在纸上或白板上，画出三层架构的示意图。将我们现有的`Playlist`类中的方法（如`addSong`, `removeSong`, `saveToFile`, `loadFromFile`）和`Main`类中的逻辑（如打印菜单、读取输入），分别归类到这三层中去。
        2.  **设计**: 为`PlaylistService`和`PlaylistRepository`这两个即将被创建的类，设计出它们的Java `interface`。例如，`PlaylistRepository`应该有一个`save(Playlist p)`方法和一个`load()`方法。
        3.  **思考**: 为什么层与层之间要通过“接口”来通信，而不是直接通过“类”的实例？（提示：这如何实现了“解耦”？它对我们上一章学的“Mock测试”有什么巨大的好处？）。

*   **`03-refactoring.qmd`: 重构：为代码建立新秩序**
    *   **内容描述**: 这是本书到目前为止，最具挑战性、也最有价值的一节。我们将动手进行一次大规模的“代码重构”。我们将创建新的包（`ui`, `service`, `repository`），创建新的类（`PlaylistController`, `PlaylistService`, `FilePlaylistRepository`），然后小心翼翼地、一步步地，将我们旧代码中的逻辑，“迁移”到它们各自正确的位置。这个过程是痛苦的，但完成后，我们的项目将浴火重生，从一个混乱的“泥球”，变成一个结构清晰、易于扩展的“水晶”。
    *   **Vibe Check (思考与练习)**:
        1.  **核心练习**: 严格按照教程的指导，完成整个三层架构的重构。
        2.  **验证**: 重构完成后，运行程序，它的**外部行为**（菜单、功能）应该和重构前**一模一样**。这证明了重构的定义：“在不改变软件外在行为的前提下，改善其内部结构。”
        3.  **测试**: 我们在第五章编写的单元测试，在这次重构中扮演了什么角色？它们是如何给我们“安全网”，确保我们在大规模修改代码时，没有破坏原有的核心逻辑？
        4.  **AI协同与扩展**: "我们现在有了一个`FilePlaylistRepository`。请AI帮我设想并设计一个`InMemoryPlaylistRepository`的接口实现。这个新的实现将把数据存在内存里，而不是文件里。我们如何能只修改一个地方（依赖注入），就让整个应用从‘文件模式’切换到‘内存模式’？" 这个练习将让你深刻体会到分层架构和面向接口编程的巨大威力。