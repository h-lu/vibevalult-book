# 第二章：从“一”到“多”：构建第一个“分子结构”

> "一生二，二生三，三生万物。" - 《道德经》

*   **本章危机**: 我们创造了“歌曲”这个数字原子，但单个的原子无法表达复杂的意义。一首歌本身价值有限，但一个精心编排的“播放列表”却能承载情感和故事。我们如何从“一”走向“多”？
*   **本章顿悟**: 我们需要一个“容器”来组织这些原子，并将其封装成一个更有意义的、更高层次的概念。`class Playlist`就是我们创造的第一个“分子结构”。

---
## 本章结构

*   **`01-why-encapsulation.qmd`: 为何要封装？从数据集合到业务对象**
    *   **内容描述**: 本节将深入探讨面向对象编程（OOP）的第一个、也是最重要的基石——封装。我们将通过一个思想实验，对比“直接在`main`方法中使用`ArrayList<Song>`”和“创建一个`Playlist`类”这两种做法的优劣。我们将从第一性原理出发，理解封装的本质是**隐藏实现细节、明确业务责任、确保数据一致性**，是构建大型可维护软件的唯一途径。
    *   **Vibe Check (思考与练习)**:
        1.  **思考**: 想象一下，如果我们的`Playlist`类不使用`private`关键字，而是`public List<Song> songs;`。调用者可以写出`myPlaylist.songs.clear()`这样的代码，在`Playlist`类完全不知情的情况下，清空了所有歌曲。这会带来什么潜在的风险？
        2.  **AI协同**: "请解释面向对象三大特性（封装、继承、多态）中，为什么‘封装’被认为是构建可维护软件系统中最重要和最基础的一个？请用一个现实世界的例子（例如，汽车的驾驶界面与内部引擎）来说明。"
        3.  **设计思考**: 除了“隐藏”数据，封装还能确保“业务规则”的执行。例如，一个播放列表最多只能有100首歌。如果`songs`列表是公开的，这个规则就无法保证。如果`songs`是私有的，我们应该在哪个方法中（例如`addSong`）加入这个检查逻辑？

*   **`02-molecular-design.qmd`: 设计播放列表分子**
    *   **内容描述**: 在理解了封装的“为什么”之后，本节将进入“怎么做”。我们将学习Java中`class`关键字的语法，定义`Playlist`类。我们将学习如何声明“成员变量”（`private List<Song> songs;`），以及如何在“构造函数”中初始化它们，并理解`this`关键字的精确含义。
    *   **Vibe Check (思考与练习)**:
        1.  **核心练习**: 完整地编写出`Playlist`类的基本骨架，包含一个私有的`name`（字符串）和一个私有的`songs`（`List<Song>`）成员变量，并编写一个构造函数来初始化这两个变量。
        2.  **编码练习**: 在`Playlist`类中添加两个“只读”方法：`getName()` 和 `getSongCount()`，分别返回播放列表的名称和其中歌曲的数量。
        3.  **破坏性实验**: 在`Playlist`的构造函数中，将参数名和成员变量名都命名为`name`，并且不使用`this`关键字 (`name = name;`)。通过调试或打印结果，看看成员变量`name`是否被正确初始化。这个实验如何证明了`this`的必要性？
        4.  **思考**: 如果我们想让一个`Playlist`在创建时就可以包含一组初始歌曲，我们应该如何设计一个新的构造函数？（提示：Java支持构造函数“重载”）。

*   **`03-collection-choice.qmd`: 选择容器：为何是ArrayList？**
    *   **内容描述**: 我们知道需要一个“容器”来存放歌曲，但Java的`java.util`包里提供了眼花缭乱的选择。本节将像一个侦探一样，从第一性原理出发，剖析最常见的几种集合类型：`ArrayList`, `LinkedList`, 和 `HashSet`。我们将通过分析它们的底层数据结构（动态数组 vs. 双向链表 vs. 哈希表），来理解它们在增、删、查等操作上根本性的性能权衡，并最终为我们当前的需求，做出最明智、最无可辩驳的选择：`ArrayList`。
    *   **Vibe Check (思考与练习)**:
        1.  **核心练习**: 在`Playlist`类中，将`addSong(Song song)`和`listSongs()`（遍历并打印所有歌曲到控制台）方法完整地实现出来。在`main`方法中创建一个`Playlist`实例，添加几首`Song`，并调用`listSongs`来验证结果。
        2.  **编码练习**: 在`Playlist`类中创建一个名为`findSongByTitle(String title)`的方法，它能根据歌名查找并返回一个`Song`对象。如果找不到，应该返回什么？（提示：返回`null`是一个选项，但它有什么风险？请向AI提问“Java中的NullPointerException是什么？为什么它被称为十亿美元的错误？”）。
        3.  **AI协同与性能实验**: "请AI生成一段代码，分别向`ArrayList`和`LinkedList`的**开头**插入10万个元素，并记录下耗时。解释为什么`LinkedList`在这种场景下快得多。" 这个实验将让你亲眼看到数据结构底层实现的巨大差异。
        4.  **设计思考**: 如果我们的`Playlist`有一个特殊需求：不允许包含重复的歌曲。那么`ArrayList`还是最佳选择吗？为了满足这个需求，我们应该将内部的`List<Song>`换成哪种集合类型？这个改动会影响`Playlist`类的公共方法签名吗？这是否再次证明了“封装”的巨大好处？