# 第三章：从“静”到“动”：赋予创造物与世界对话的能力

> "存在，就是被感知。" - 乔治·贝克莱

*   **本章危机**: 我们创造的`Playlist`分子是“死”的。它存在于代码中，但我们无法在程序运行时与它互动。一个无法被感知的创造物，真的存在吗？
*   **本章顿悟**: 我们需要打破代码与现实世界的“第四面墙”，建立一个持续的“对话通道”，让用户可以通过输入来感知和改变我们的创造物。这个通道，就是“交互式循环”。

---
## 本章结构

*   **`01-why-interactive.qmd`: 为何需要交互？批处理 vs. 事件循环**
    *   **内容描述**: 本节将探讨程序与世界互动的两种根本模式。我们将理解“批处理”程序（如一个视频转码工具）的“一次性”本质，并将其与“交互式”程序（如一个文本编辑器）的“持续性”进行对比。我们将从第一性原理出发，揭示几乎所有现代软件的核心都是一个“事件循环”（Event Loop），它赋予了软件“生命”，使其能持续地“等待输入 -> 处理 -> 产生输出”。
    *   **Vibe Check (思考与练习)**:
        1.  **思考**: 我们每天使用的软件，哪些是“批处理”模式，哪些是“交互式”模式？它们的体验有何根本不同？为什么你不能和一个“批处理”程序“对话”？
        2.  **AI协同**: "请解释一下操作系统中‘阻塞I/O’（Blocking I/O）的概念。当我们的Java程序调用`Scanner.nextLine()`时，为什么我们的程序会‘暂停’？此时CPU在做什么？"
        3.  **深入思考**: 除了我们即将构建的命令行界面（CLI），还有哪些常见的用户交互界面（GUI, Web, Voice）？你能否想象一下它们各自的“事件循环”可能是在等待什么不同类型的“事件”？

*   **`02-dialogue-channel.qmd`: 建立对话通道：主循环与用户输入**
    *   **内容描述**: 理论之后，立即动手。本节我们将编写出赋予我们应用“生命”的核心代码：一个`while(true)`无限循环。我们将学习如何在这个循环中，向用户展示一个菜单，并使用`Scanner`类来读取用户的输入。我们还将第一次直面与外部世界交互的风险——用户可能不会按我们的预期输入，并学习如何用`try-catch`来处理潜在的输入异常，避免程序崩溃。
    *   **Vibe Check (思考与练习)**:
        1.  **核心练习**: 编写一个完整的`main`方法，包含一个`while(true)`循环。在循环的开始，打印出一个包含“1. 添加歌曲”、“2. 查看列表”、“0. 退出”的菜单。然后，尝试读取用户输入的整数选项。
        2.  **破坏性实验**: 在程序提示你输入数字时，故意输入一个字母（例如 "abc"）。程序会发生什么？（提示：`InputMismatchException`）。现在，使用`try-catch`块来捕获这个异常，并向用户打印一条友好的错误消息（例如“无效输入，请输入数字！”），然后使用`scanner.next()`来清除错误的输入，确保循环可以继续。
        3.  **编码练习**: 实现“退出”功能。当用户输入的数字是0时，使用`break`关键字优雅地跳出`while(true)`循环，并在循环结束后打印一条“感谢使用！”的消息。
        4.  **思考**: `while(true)`看起来像个无限循环，它会耗尽CPU资源吗？为什么不会？（提示：`scanner.nextInt()`在做什么？）

*   **`03-command-protocol.qmd`: 定义沟通协议：Switch与方法调用**
    *   **内容描述**: 我们已经能接收用户的指令“数字”了，现在需要将这些数字“翻译”成对我们`Playlist`对象的具体操作。本节将学习如何使用`switch`语句来构建一个清晰的“指令分发中心”。我们将把之前所有零散的测试代码（创建`Playlist`，添加`Song`等）整合起来，根据用户的选择，精确地调用`playlist`对象的相应方法，最终将我们应用的“交互界面”和“核心业务逻辑”完美地连接在一起。
    *   **Vibe Check (思考与练习)**:
        1.  **核心练习**: 将`main`方法中的逻辑与`Playlist`类连接起来。在`main`方法的开头创建一个`Playlist`实例。然后，在`switch`语句中，为“1”（添加歌曲）和“2”（查看列表）这两个`case`编写代码。对于`case 1`，你需要提示用户输入歌曲信息，创建一个新的`Song`对象，并调用`playlist.addSong()`。对于`case 2`，你需要调用`playlist.listSongs()`。
        2.  **编码练习**: 在菜单中增加一个新的选项，例如“3. 删除歌曲”。为此，你需要在`Playlist`类中实现一个`removeSong(int songIndex)`方法。然后在`main`方法的`switch`中添加`case 3`，提示用户输入要删除的歌曲编号，并调用这个新方法。
        3.  **健壮性练习**: 你的`removeSong`方法需要处理用户输入的索引可能是无效的（例如，小于0或大于列表大小）情况吗？你应该在哪里（`main`方法还是`Playlist`类）做这个检查？为什么？（提示：思考“封装”和“责任划分”）。
        4.  **AI协同与代码重构**: "请AI帮我将传统的`switch`语句，重构为Java 17以后更简洁、更安全的`switch`表达式。对比两种写法的优劣。"
        5.  **深入思考**: 我们目前是通过“方法调用”来将UI和业务逻辑连接起来的。在更复杂的GUI或Web应用中，这种直接调用的方式可能会导致“紧耦合”。请向AI提问：“什么是‘观察者模式’（Observer Pattern）？它如何帮助UI和业务逻辑实现更松散的耦合？”