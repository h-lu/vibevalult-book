# 第五章：对抗“脆弱”：我们如何相信自己写下的代码？

> "未经测试的代码就是错误的代码。" - Kent Beck (JUnit创始人)

*   **本章危机**: 我们的数据可以永久保存了，但也因此变得无比“珍贵”。我们发现自己不敢轻易修改代码了。任何一个微小的改动，都可能引入一个bug，从而污染我们宝贵的“永久记忆”（数据文件）。我们的代码是脆弱的、不可信的。
*   **本章顿悟**: 信任不能来自“希望”或“感觉”，必须来自可重复的、自动化的“证明”。我们需要一个不知疲倦的“机器人”，在我们每次修改代码后，自动地、严格地验证其正确性。这个机器人，就是“单元测试”。

---
## 本章结构 (重构版)

*   **`01-why-test.qmd`: 信任危机与安全网**
    *   **内容描述**: 本节将从第一性原理出发，剖析“手动测试”的根本缺陷——一次性、不可重复、依赖人类注意力。我们将揭示自动化测试的本质——**将“验证”本身代码化**，并介绍“测试金字塔”模型，理解为何要以大量的、快速的单元测试作为构建信任的基石。
    *   **Vibe Check (思考与练习)**:
        1.  **思考**: 想象一下，在你完成了整个项目后，你修改了一个非常底层的`Song`类的一个小逻辑。如果没有自动化测试，你需要手动重新测试多少个功能才能确保没有引入新的bug？这个过程需要多长时间？你有多大把握能测全所有场景？
        2.  **AI协同**: "请解释测试金字塔模型（单元测试、集成测试、端到端测试）。为什么我们应该拥有大量的单元测试，而审慎地编写端到端测试？请用开发成本、执行速度和反馈周期的角度来分析。"
        3.  **设计思考**: “测试驱动开发”（TDD）是一种“先写测试，再写实现”的开发模式。你认为这种模式可能带来什么好处和挑战？

*   **`02-setup-lab.qmd`: 搭建测试实验室：JUnit 5初体验**
    *   **内容描述**: 在本节中，我们将迈出自动化测试的第一步：搭建环境。我们将学习标准的测试目录结构(`src/test/java`)，如何在`build.gradle.kts`中添加JUnit 5依赖，并编写一个最简单的“Hello, Test!”程序。目标是熟悉工具链，并成功运行第一个测试，看到代表胜利的“绿色”标记。
    *   **Vibe Check (思考与练习)**:
        1.  **核心练习**: 在`build.gradle.kts`中添加JUnit 5的依赖。创建`src/test/java/com/vibevault`目录。创建`VibeVaultSanityTest.java`并编写一个`assertTrue(true)`的测试，然后成功运行它。
        2.  **破坏性实验**: 将测试改为`assertTrue(false)`并运行。观察IDE中测试失败的红色报告。理解测试失败时工具会给你什么样的反馈。
        3.  **AI协同**: "请解释`@Test`注解的作用。当我们在IDE中点击“运行测试”时，JUnit框架在背后大致做了哪些事情来找到并执行这个被注解的方法？"

*   **`03-assertion-language.qmd`: 精确的断言：AssertJ的流畅表达**
    *   **内容描述**: 有了运行测试的能力，我们现在需要学习如何精确地“断言”我们的期望。本节将引入强大的断言库AssertJ，学习其`assertThat(...).isEqualTo(...)`等流畅、可读的API。我们将为`Playlist`类的纯业务逻辑（不涉及文件操作的方法）编写第一个有意义的单元测试，学会用代码来“证明”其正确性。
    *   **Vibe Check (思考与练习)**:
        1.  **核心练习**: 在`build.gradle.kts`中添加AssertJ的依赖。为`Playlist`的`addSong`方法编写测试，断言添加歌曲后，播放列表的歌曲数量和内容是正确的。
        2.  **编码练习**: 为`Playlist`的`removeSong`方法编写测试。断言成功删除歌曲后，列表大小会减一，且被删除的歌曲不再存在于列表中。
        3.  **异常测试**: 为`removeSong`方法编写一个测试，当尝试删除一个越界的索引时（例如-1），程序应该抛出`IndexOutOfBoundsException`。提示: 使用AssertJ的`assertThatThrownBy`。

*   **`04-isolation-principle.qmd`: 隔离的原则：为何测试讨厌“真实世界”**
    *   **内容描述**: 当我们尝试测试`saveToFile`这类方法时，会发现测试会真实地读写磁盘，这使得测试变慢、变不稳定，不再是“单元”测试。本节将深入探讨单元测试的灵魂——**隔离**。为了实现隔离，我们将进行一次重要的**代码重构**：引入`PlaylistRepository`接口，将业务逻辑与持久化逻辑彻底解耦。
    *   **Vibe Check (思考与练习)**:
        1.  **设计思考**: `Playlist`类在重构前，同时关心“歌曲列表管理”和“文件读写”，这违背了我们常说的一个设计原则。请问是哪个原则？请用自己的话描述它。
        2.  **AI协同**: "请解释SOLID原则中的“D”——依赖倒置原则（Dependency Inversion Principle）。我们本次将`PlaylistService`依赖于`PlaylistRepository`接口，而不是`FilePlaylistRepository`实现，是如何体现这个原则的？"
        3.  **联想**: 除了文件系统，请再列举至少3个在真实世界应用中常见的、在单元测试时需要被隔离的“外部依赖”。

*   **`05-faking-reality.qmd`: 创造“假想敌”：Mockito的打桩(Stubbing)**
    *   **内容描述**: 代码重构后，我们的服务依赖于一个接口。在测试中，我们如何为这个接口提供一个“假的”实现呢？本节将引入强大的Mockito框架，学习使用`@Mock`来创建一个“测试替身”，并用`when(...).thenReturn(...)`来“打桩”（Stubbing）——即预先设定这个假想敌在被调用时应该返回什么结果，从而完全掌控我们的测试环境。
    *   **Vibe Check (思考与练习)**:
        1.  **核心练习**: 在`build.gradle.kts`中添加Mockito的依赖。创建`PlaylistServiceTest.java`，使用`@Mock`和`@InjectMocks`。编写一个测试，使用`when(repository.load(...)).thenReturn(...)`来“打桩”，模拟加载一个已存在的播放列表。
        2.  **编码练习**: 编写一个测试，模拟当`repository.load(...)`返回一个空的`Playlist`时，`addSongToPlaylist`方法的行为是否正确。
        3.  **异常打桩**: 编写一个测试，模拟当`repository.load(...)`直接抛出`IOException`时，你的`PlaylistService`是否能正确地将异常继续向上抛出。提示: 使用Mockito的`when(...).thenThrow(...)`。

*   **`06-verifying-actions.qmd`: 验证“副作用”：Mockito的行为验证(Verification)**
    *   **内容描述**: 对于像`save`这样没有返回值（`void`）的方法，我们无法断言其结果。但它确实产生了“副作用”（调用了另一个对象的方法）。本节将学习Mockito的另一个核心功能——**行为验证**。我们将使用`verify(...)`方法来检查我们的代码是否按预期与它的依赖（Mock对象）进行了交互，从而能够测试这些关键的副作用。
    *   **Vibe Check (思考与练习)**:
        1.  **核心练习**: 在`addSongToPlaylist`的测试中，增加`verify(repository).save(playlist)`，以验证`save`方法被正确调用了。
        2.  **精确验证**: 修改练习1的验证，使用`verify(repository, times(1)).save(...)`来确保`save`方法被**恰好调用了一次**。
        3.  **反向验证**: 编写一个测试，在`load`方法抛出`IOException`的场景下，**验证`save`方法从未被调用过**。提示: 使用`verify(repository, never()).save(...)`。
        4.  **AI协同**: "请AI解释一下Mockito的`ArgumentCaptor`是做什么用的？它和`verify`方法如何结合使用，来对一个被调用方法的参数进行更详细的断言？"