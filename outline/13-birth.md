# 第十三章：对抗“环境”：容器化，代码的“生命胶囊”

> "在我的电脑上可以运行。" - 每一个开发者都曾说过的谎言

*   **本章危机**: “在我的电脑上可以运行，但在你的电脑上/服务器上就不行”——这个软件开发中最古老、最令人沮丧的诅咒，现在降临到了我们头上。环境的细微差异（Java版本、操作系统、依赖库）导致了无尽的麻烦。
*   **本章顿悟**: 我们交付的，不应该是“代码”，而应该是一个包含了代码及其完整、一致的运行环境的、自给自足的“生命胶囊”。这个胶囊，就是“容器”。

---
## 本章结构

*   **`13.1-why-container.md`: 为何需要容器化？**
    *   **核心思想**: 从第一性原理出发，深入探讨“在我的电脑上可以运行”这个问题的根源——环境不一致。我们将对比传统的虚拟机（VM）和现代的容器（以Docker为代表）在隔离性、资源消耗和启动速度上的差异，揭示容器化的本质。
    *   **Vibe Check**:
        1.  **思考**: 虚拟机和容器，哪个更“轻量级”？为什么？
        2.  **AI协同**: "请解释一下Docker的核心概念：‘镜像’（Image）和‘容器’（Container）之间的关系。"

*   **`13.2-dockerfile.md`: 编写应用的“DNA序列”**
    *   **核心思想**: 学习如何编写`Dockerfile`，这是一个精确定义了如何构建我们应用运行环境的“基因蓝图”。我们将逐行解析`Dockerfile`中的常用指令（如`FROM`, `COPY`, `RUN`, `CMD`），并构建出我们VibeVault应用的第一个Docker镜像。
    *   **Vibe Check**:
        1.  **核心练习**: 为你的Spring Boot后端应用编写一个`Dockerfile`，并成功构建运行。
        2.  **AI协同与优化**: "请为我的Java Spring Boot应用生成一个优化的、使用多阶段构建的`Dockerfile`。"

*   **`13.3-docker-compose.md`: 指挥一场“容器交响乐”**
    *   **核心思想**: 学习如何编写`docker-compose.yml`，这是一个“总乐谱”，用来声明式地编排和启动我们整个应用（后端服务 + 数据库）。我们将理解`services`, `networks`, `volumes`等概念，并最终通过一个命令（`docker-compose up`）启动整个VibeVault系统。
    *   **Vibe Check**:
        1.  **核心练习**: 编写一个`docker-compose.yml`文件，同时启动后端服务和PostgreSQL数据库。
        2.  **编码练习**: 为PostgreSQL服务添加一个“数据卷”（Volume），以确保数据在容器重启后不会丢失。