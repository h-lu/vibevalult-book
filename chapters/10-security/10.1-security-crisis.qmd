# 10.1 守门人：AI 托管的安全配置

> "安全不是可选项，而是默认项。" —— 现代Web开发的第一法则

## 本节危机：裸奔的系统，看不见的威胁

打开你第八章完成的代码。运行它，访问 `http://localhost:8080/api/playlists`。一切正常，数据返回了。

现在，想象一个场景：

*   **场景一：恶意删除**  
    一个陌生人，在地球的另一端，在他的电脑上打开终端，输入：

    ```bash
    curl -X DELETE http://your-server.com/api/playlists/my-precious-playlist
    ```
    你的心血，瞬间消失。

*   **场景二：数据泄露**  
    你的应用存储了用户的私人歌单。但因为没有任何保护，任何人都可以通过简单的GET请求，获取所有用户的隐私数据。

*   **场景三：DDoS攻击**  
    没有任何限流机制，攻击者可以每秒发送数万次请求，耗尽你的服务器资源，导致合法用户无法访问。

**这就是我们现在的处境：一个毫无防备的系统，就像一栋没有门锁的房子，大门敞开，欢迎所有人进来搬走任何东西。**

我们面临的根本问题是：**在Web的世界里，"默认信任"是致命的。我们需要一个守门人，一个能够识别"谁在敲门"、"他是否有权进入"的机制。**

## 本节顿悟：Spring Security——"默认拒绝"的守护者

Spring Security是Java生态中最强大、最成熟的安全框架。它的核心哲学是：**默认拒绝一切，明确允许部分**。

这与我们之前"默认开放"的开发方式截然相反。在Spring Security的世界观里：

*   **默认状态**：所有HTTP请求都被视为"可疑"，一律拦截。
*   **白名单机制**：我们需要明确告诉它："这些路径（如登录接口）可以让任何人访问。"
*   **认证要求**：对于其他所有路径，必须证明身份（Authentication）才能通过。
*   **授权检查**：即使身份合法，也要检查是否有权限（Authorization）执行特定操作。

这种"零信任"的设计，虽然初期配置略显繁琐，但它为我们的应用筑起了一道坚实的防线。

### Vibe Coding策略：AI托管配置

Spring Security的配置代码充斥着各种过滤器链（Filter Chain）、适配器（Adapter）、认证管理器（Authentication Manager）。这些概念抽象且晦涩，而且**版本迭代极快**。

例如，Spring Security 5.x 广泛使用的 `WebSecurityConfigurerAdapter` 在6.x中已被废弃，改用基于Lambda的 `SecurityFilterChain`。如果你的AI助手训练数据过时，它可能会生成大量无法编译的旧代码。

**我们的策略**：

1.  **我们负责定义策略**：明确说明"哪些路径开放"、"哪些路径需要认证"。
2.  **AI负责生成配置**：让AI基于最新文档（通过Context7 MCP）生成符合Spring Security 6.x规范的标准代码。
3.  **我们负责审查**：检查关键配置是否符合预期，而不是逐行理解每个API调用。

---

## 第一步：引入Spring Security依赖

在`gradle/libs.versions.toml`的`[libraries]`区域添加：

```toml
[libraries]
# ... 其他依赖
spring-boot-starter-security = { module = "org.springframework.boot:spring-boot-starter-security" }
```

然后在`build.gradle.kts`的`dependencies`块中添加：

```kotlin
dependencies {
    // ... 其他依赖
    implementation(libs.spring.boot.starter.security)
}
```

### 重启应用：见证"默认拒绝"

保存文件，重启你的Spring Boot应用。然后再次访问 `http://localhost:8080/api/playlists`。

**惊喜来了**：你看到的不再是熟悉的JSON数据，而是一个**401 Unauthorized**错误页面，或者浏览器弹出一个登录对话框。

这不是Bug，这是**Spring Security的默认行为**。它已经自动为你的应用安装了一套完整的安全机制：

*   **默认拦截**：所有路径都需要认证。
*   **自动登录页**：Spring自动生成了一个基本的登录表单。
*   **默认用户**：控制台日志中会打印一个随机密码（用户名是`user`）。

虽然这个默认配置不适合我们的REST API场景（我们需要的是JWT，而不是表单登录），但它清晰地展示了Spring Security的理念：**先锁门，再定规矩。**

---

## 第二步：AI托管配置——定义我们的安全策略

现在，我们需要"驯服"这个过于严格的守门人，让它理解我们的业务规则。

### 我们的安全策略

在开始之前，让我们明确定义我们的需求（这是与AI沟通的关键）：

1.  **无状态（Stateless）**：我们构建的是REST API，不使用Session，所有认证信息通过Token传递。
2.  **白名单路径**：
    *   `/api/auth/signup` 和 `/api/auth/login`：任何人都可以注册和登录，无需认证。
    *   暂时允许 `/api/playlists`（GET请求）匿名访问，方便我们测试。
3.  **默认拒绝**：除白名单外的所有请求，都必须提供有效的认证凭证。
4.  **禁用CSRF**：因为我们使用Token（放在Header），而不是Cookie，所以不需要CSRF保护。

### 使用AI生成SecurityConfig

现在，复制以下Prompt给你的AI助手（如果你使用支持MCP的编辑器，记得添加`use context7`）：

::: {.callout-tip}
## 🤖 AI Prompt

"我正在使用 **Spring Boot 3.2** 和 **Spring Security 6.x**。

请帮我生成一个完整的 `SecurityConfig` 配置类，要求如下：

1.  **包路径**：`com.vibevault.config`
2.  **无状态（Stateless）**：
    *   禁用CSRF保护（因为我们使用Token而非Cookie）
    *   Session策略设为 `STATELESS`
3.  **白名单**：
    *   允许 `/api/auth/**`（所有认证相关接口）匿名访问
    *   允许 `/api/playlists`（仅GET请求）匿名访问
4.  **默认拒绝**：所有其他请求必须认证（authenticated）
5.  **代码风格**：
    *   使用 `SecurityFilterChain` Bean（不要使用已废弃的 `WebSecurityConfigurerAdapter`）
    *   使用Lambda DSL配置风格
    *   添加详细的中文注释

请直接给出完整的Java代码。

use context7"
:::

### 审查AI的输出

AI应该生成类似以下的代码。请创建文件 `com/vibevault/config/SecurityConfig.java`，并粘贴AI生成的代码。

::: {.callout-important}
**不要直接复制下面的代码**。Spring Security版本更新极快，API经常变动。请务必使用AI生成的、针对你当前版本的代码。下面的代码仅供参考，用于理解核心配置项。
:::

```java
// 参考代码：SecurityConfig的核心结构
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // 1. 禁用CSRF（因为我们使用Token）
            .csrf(csrf -> csrf.disable())
            
            // 2. 设置无状态Session（不保存用户状态）
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            
            // 3. 定义白名单和拦截规则
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/auth/**").permitAll() // 允许注册/登录
                .requestMatchers(HttpMethod.GET, "/api/playlists").permitAll() // 临时允许查看歌单
                .anyRequest().authenticated() // 其他所有请求都需要认证
            );

        return http.build();
    }
}
```

### 代码审查清单

在使用AI生成的代码前，请务必检查以下关键点：

*   ✅ 是否使用了 `SecurityFilterChain` Bean，而非废弃的 `WebSecurityConfigurerAdapter`？
*   ✅ 是否使用Lambda DSL（`auth -> auth...`），而非旧式的链式调用？
*   ✅ 是否包含 `.csrf(csrf -> csrf.disable())`？
*   ✅ 是否配置了 `SessionCreationPolicy.STATELESS`？
*   ✅ 白名单路径是否正确（`/api/auth/**` 和 GET `/api/playlists`）？
*   ✅ 是否有 `.anyRequest().authenticated()`作为兜底规则？

如果以上都通过，恭喜！你已经成功配置了Spring Security的第一道防线。

---

## 第三步：验证配置（Vibe Check）

重启应用，让我们验证守门人是否按照我们的规则工作。

### 测试一：白名单路径（应该通过）

打开浏览器或使用`curl`，访问：

```bash
curl http://localhost:8080/api/playlists
```

**预期结果**：200 OK，返回播放列表的JSON数据。（因为我们将GET `/api/playlists`加入了白名单）

### 测试二：受保护的路径（应该被拦截）

尝试删除一个播放列表：

```bash
curl -X DELETE http://localhost:8080/api/playlists/my-favorites
```

**预期结果**：403 Forbidden（禁止访问）。因为DELETE请求不在白名单中，且我们没有提供认证凭证。

### 测试三：检查Session行为

在浏览器的开发者工具中（F12 → Network），访问API，检查响应头中是否**没有** `Set-Cookie` 字段。

**预期结果**：没有Cookie被设置，证明我们的STATELESS配置生效了。

---

## Vibe Deep Dive：深入理解核心概念

### CSRF（跨站请求伪造）：为什么我们可以禁用？

**攻击场景**（传统Session方式）：

1.  你登录了银行网站A，浏览器存储了Session Cookie。
2.  你访问了恶意网站B。
3.  网站B的页面中隐藏了一个表单，自动向银行网站A发送转账请求。
4.  因为浏览器会**自动携带**银行网站A的Cookie，请求看起来像是你发出的，攻击成功。

**为什么我们不需要CSRF保护？**  
我们使用的是Token认证（后续章节会实现），Token存储在`localStorage`或前端变量中，放在HTTP Header的`Authorization`字段里发送。浏览器**不会自动携带**Header，恶意网站无法伪造这个Token。

**例外情况**：如果你未来改用Cookie存储Token（不推荐），那么**必须**重新启用CSRF保护。

### Stateless（无状态）：为什么它是REST API的标配？

**有状态（Stateful）方式的问题**：

*   服务器需要在内存中存储每个用户的登录状态（Session）。
*   用户量大时，Session占用大量内存。
*   如果你有多台服务器（负载均衡），Session需要在服务器间共享（Session复制或Redis存储），增加复杂度。

**无状态（Stateless）的优势**：

*   服务器不存储任何用户状态，每个请求都携带完整的认证信息（JWT Token）。
*   服务器可以随意扩展（Scale Out），任何一台服务器都能处理任何一个请求。
*   符合REST架构的无状态约束，天然支持分布式部署。

**代价**：每个请求都要携带Token，网络传输量略微增加（通常几百字节，可以接受）。

---

## Vibe Check（动手与思考）

1.  **核心练习**：
    *   完成上述三个测试，确保白名单和默认拒绝都按预期工作。
    *   尝试访问一个不存在的路径（如`/api/unknown`），观察返回的状态码。

2.  **编码练习**：
    *   如果你希望暂时开放所有`/api/playlists/**`路径（包括POST、DELETE）用于测试，应该如何修改`SecurityConfig`？（提示：调整`requestMatchers`的参数）
    *   完成后记得改回来，保持安全意识。

3.  **思考练习**：
    *   如果不禁用CSRF，但又想使用Token认证，Spring Security提供了什么机制？（提示：查阅`CookieCsrfTokenRepository`）
    *   为什么生产环境中，白名单路径应该尽可能少？

4.  **AI协同**：
    
    > "请解释Spring Security中`@EnableWebSecurity`注解的作用。如果不加这个注解，会发生什么？"
    
    > "Spring Security 6.x相比5.x，在配置方式上有哪些重大变化？请列举至少3个废弃的API和它们的替代方案。"

---

**守门人已就位。** 但他现在只能说"不"，还不能识别"好人"。在下一节，我们将教会他识别身份——建立用户系统和登录机制。
