# 10.5 握手：全栈安全大一统

> "前端和后端，终于在安全的拥抱中相遇。" —— 全栈开发的高光时刻

## 本节危机：后端固若金汤，前端无从下手

恭喜！经过前四节的努力，你的后端已经建立了一套完整的安全体系：

*   ✅ Spring Security守门（10.1）
*   ✅ 用户认证系统（10.2）
*   ✅ JWT无状态认证（10.3）
*   ✅ 基于所有权的授权（10.4）

但现在有个问题：**你的第9章React前端完全不知道这一切的存在**。

**当前状态**：

*   前端尝试访问`GET /api/playlists`（需要Token） → 403 Forbidden
*   前端想添加歌曲 → 403 Forbidden
*   前端甚至不知道如何让用户"登录"

**我们面临的挑战**：

1.  前端需要一个**登录页面**，让用户输入用户名和密码。
2.  登录成功后，前端需要**保存JWT Token**。
3.  所有后续API请求，前端都要在HTTP Header中**携带Token**。
4.  如果Token过期或无效，前端要能**优雅地处理**（如跳转回登录页）。

**这一节，我们将完成全栈应用的最后一环：让React前端和Spring Boot后端，通过JWT实现安全握手。**

```{mermaid}
sequenceDiagram
    participant React as React前端
    participant API as Spring Boot后端
    participant DB as 数据库
    
    Note over React, API: 阶段一：握手（登录）
    React->>API: POST /api/auth/login (user, pass)
    API->>DB: 验证账号密码
    API-->>React: 返回 JWT Token
    React->>React: localStorage.setItem('token', jwt)
    
    Note over React, API: 阶段二：通信（携带信物）
    React->>React: 从localStorage取出Token
    React->>API: GET /api/playlists <br/> Header: Authorization: Bearer <token>
    API->>API: 验证Token签名 & 有效期
    API-->>React: 返回数据 (200 OK)
    
    Note over React, API: 阶段三：分手（Token过期）
    React->>API: GET /api/playlists (Token已过期)
    API-->>React: 403 Forbidden
    React->>React: 清除Token，跳转回登录页
```

---

## 第一步：配置CORS（跨域资源共享）

在连接前端之前，我们必须解决一个浏览器安全机制带来的问题：**跨域（CORS）**。
前端运行在 `http://localhost:5173`，后端运行在 `http://localhost:8080`。默认情况下，浏览器禁止这种跨域请求。

修改 `SecurityConfig.java`，允许来自前端的请求：

::: {.callout-tip}
## 🤖 AI Prompt
"修改 `SecurityConfig`，配置 CORS（跨域资源共享）。
要求：

1. 允许来自 `http://localhost:5173` 的请求。
2. 允许 GET, POST, PUT, DELETE, OPTIONS 方法。
3. 允许所有 Headers。
4. 允许携带 Credentials。"
:::

---

## 第二步：创建Login组件

回到你第9章创建的React项目（`vibevault-frontend`）。让我们创建一个登录页面。

### 使用AI生成Login组件

::: {.callout-tip}
## 🤖 AI Prompt

"请帮我创建一个React登录组件 `Login.jsx`，要求如下：

1.  **UI设计**：
    *   深色主题背景（#1a1a2e）
    *   渐变卡片容器
    *   用户名和密码输入框
    *   登录按钮（悬停时有动画效果）
    *   错误信息展示（红色，明显）

2.  **功能要求**：
    *   使用`useState`管理username, password, error状态
    *   点击登录按钮后，发送POST请求到 `http://localhost:8080/api/auth/login`
    *   如果成功（200 OK），将返回的`token`存入`localStorage`
    *   **关键**：调用父组件传入的 `onLoginSuccess(username)` 回调函数
    *   如果失败，显示错误信息（如"用户名或密码错误"）

3.  **代码风格**：
    *   使用函数组件和Hooks
    *   添加详细注释
    *   使用async/await处理异步

请提供完整代码，并同时生成对应的 `Login.css` 样式文件（使用现代CSS特性）。"
:::

### 创建样式文件

让AI为你生成漂亮的CSS样式。

::: {.callout-tip}
## 🤖 AI Prompt
"请为上面的 `Login.jsx` 生成配套的 `Login.css`。
设计风格：
1.  **Cyberpunk/Modern Vibe**：使用深色背景、霓虹蓝/紫色点缀。
2.  **玻璃拟态**：登录卡片使用半透明磨砂效果（backdrop-filter）。
3.  **交互反馈**：输入框聚焦时发光，按钮悬停时上浮。"
:::

---

## 第三步：修改App.jsx，管理登录状态

现在我们需要配置路由：未登录时显示登录页，已登录时显示歌单列表。

::: {.callout-tip}
## 🤖 AI Prompt
"修改 `App.jsx` 以支持登录状态管理：
1. 使用 `useState` 管理 `isAuthenticated` 和 `currentUser`。
2. 初始化时检查 `localStorage` 中是否有 Token。
3. 如果未登录，渲染 `<Login />` 组件。
4. 如果已登录，渲染主界面，并显示 '欢迎, username' 和 '退出' 按钮。"
:::

---

## 第四步：修改API工具，统一Token管理

::: {.callout-tip}
## 🤖 AI Prompt
"修改 `src/utils/api.js`，创建一个通用的 `handleResponse` 函数：
1. 检查 401/403 状态码：如果遇到，清除 Token 并刷新页面（强制登出）。
2. 检查其他错误状态码：抛出错误。
3. **关键**：健壮地解析响应体。先读取 `text()`，如果为空则返回 `null`，否则 `JSON.parse()`。
4. 更新 `apiGet`, `apiPost`, `apiDelete`，自动在 Header 中添加 `Authorization: Bearer <token>`。"
:::

---

## 第五步：终极验证（The Final Vibe Check）

### 测试一：完整登录流程

1.  **确保后端运行**：`./gradlew bootRun`（在`chapter-code/ch10`目录）
2.  **确保前端运行**：`npm run dev`（在`vibevault-frontend`目录）
3.  **注册用户**（使用curl或Postman）：
    ```bash
    curl -X POST http://localhost:8080/api/auth/signup \
      -H "Content-Type: application/json" \
      -d '{"username": "testuser", "password": "password123"}'
    ```
4.  **打开浏览器**，访问 `http://localhost:5173`
5.  **应该看到登录页**（因为没有Token）
6.  **输入用户名和密码**，点击登录
7.  **应该跳转到主页**，显示"欢迎, testuser"

### 测试二：Token持久化

1.  登录后，**刷新页面**（F5）
2.  **应该仍然显示主页**，不会跳回登录页（因为Token保存在localStorage）
3.  **打开开发者工具**（F12） → Application → Local Storage
4.  **应该能看到**：`jwtToken`和`username`两个键值对

### 测试三：退出登录

1.  点击"退出登录"按钮
2.  **应该清空Token并跳转回登录页**

### 测试四：Token过期处理

1.  **修改后端**，将JWT有效期改为10秒（在`JwtService.java`中）
2.  登录后，**等待11秒**
3.  尝试刷新页面或点击其他功能
4.  **应该自动跳转回登录页**（因为Token过期，API返回403）

---

## Vibe Deep Dive：前端Token存储的安全权衡

### LocalStorage vs HttpOnly Cookie

| 存储方式 | 优点 | 缺点 | 适用场景 |
|---------|------|------|---------|
| **localStorage** | • 前端完全控制<br>• 易于实现和调试<br>• 支持跨域 | • 易受XSS攻击<br>• 无法设置过期时间 | 中小型项目、学习Demo |
| **httpOnly Cookie** | • 防御XSS攻击<br>• 浏览器自动管理 | • 需要重新启用CSRF保护<br>• 跨域配置复杂 | 企业级应用、高安全需求 |

**当前选择**：我们使用`localStorage`，因为：
1.  简单易懂，适合学习
2.  前端能完全控制Token（便于调试）
3.  配合HTTPS和CSP（Content Security Policy），风险可控

**生产环境建议**：
*   对于高安全要求的应用（如银行应用），使用httpOnly Cookie + CSRF Token
*   对于一般Web应用，localStorage + HTTPS + CSP是可接受的方案

### React中的Protected Route模式

更专业的做法是使用React Router创建"受保护路由"：

```jsx
// 示例：使用React Router的Protected Route
import { Navigate } from 'react-router-dom';

function ProtectedRoute({ children }) {
  const token = localStorage.getItem('jwtToken');
  
  if (!token) {
    return <Navigate to="/login" replace />;
  }
  
  return children;
}

// 在路由配置中使用
<Route path="/playlists" element={
  <ProtectedRoute>
    <PlaylistList />
  </ProtectedRoute>
} />
```

---

## 恭喜！你已经完成了全栈安全闭环

让我们回顾一下这趟旅程：

### 后端（Spring Boot）

*   ✅ **10.1 守门人**：Spring Security拦截所有未认证请求
*   ✅ **10.2 身份**：User实体 + BCrypt密码加密 + 注册/登录接口
*   ✅ **10.3 护照**：JWT生成和验证 + JwtFilter自动验身份
*   ✅ **10.4 规矩**：基于所有权的授权 + @PreAuthorize注解

### 前端（React）

*   ✅ **登录界面**：美观的Login组件
*   ✅ **Token管理**：存储、携带、自动清理
*   ✅ **错误处理**：401/403自动跳转登录
*   ✅ **用户体验**：持久登录状态 + 退出功能

### 系统特性

*   **无状态**：服务器不存储Session，天然支持水平扩展
*   **安全**：密码BCrypt加密，Token签名防篡改
*   **用户友好**：一次登录24小时有效，无需频繁输入密码
*   **权限控制**：用户只能操作自己的资源

---

## Vibe Check（动手与思考）

1.  **核心练习**：
    *   完成上述四个测试，确保完整的登录流程工作正常。
    *   使用浏览器开发者工具的Network标签，观察登录请求的Request/Response，验证Token是否正确传递。

2.  **编码练习**：
    *   添加"注册"功能到前端：创建`Signup.jsx`组件，让用户可以在界面上注册（而不是用curl）。
    *   为删除歌单添加确认对话框："确定要删除吗？此操作不可撤销。"
    *   实现"记住我"功能：添加一个复选框，勾选时Token有效期延长到7天。

3.  **安全思考**：
    *   如果攻击者在浏览器控制台执行`localStorage.getItem('jwtToken')`，他能拿到Token吗？这是XSS攻击的一种形式吗？如何防御？
    *   如果用户在多个设备登录（手机、电脑），当前的JWT方案能支持"在其他设备强制下线"吗？为什么？如何实现？

4.  **AI协同**：
    
    > "请解释OAuth 2.0和JWT的关系。如果我要实现'使用Google账号登录VibeVault'，应该使用哪种方案？"
    
    > "请解释CSP (Content Security Policy) 如何帮助防御XSS攻击。给我一个适合VibeVault应用的CSP配置示例。"

---

**你已经完成了一个真正的、可投入使用的全栈Web应用！** 它有：

*   完整的前后端分离架构
*   安全的用户认证和授权体系
*   优雅的无状态Token方案
*   专业的错误处理和用户体验

下一章，我们将把这个应用打包、部署到云端，让全世界的人都能访问你的VibeVault。
