---
title: "为何选择JWT？无状态的认证"
---

# 10.2 为何选择JWT？无状态的认证

> “信任的本质，在于我们如何证明‘你是谁’。”  

## 危机：HTTP的“健忘症”

在上一节，我们明确了需要通过“认证”来记住我们的用户。但这里潜藏着一个巨大的技术挑战，它源于Web的基石——HTTP协议的一个核心特性：**无状态 (Stateless)**。

HTTP的无状态意味着，服务器不会记录任何关于客户端请求的信息。每一个请求对于服务器来说都是一个全新的、独立的事件。当你登录成功后，下一次你再次向服务器发送请求（比如，获取你的播放列表），服务器已经完全“忘记”了你是谁。它就像一个只有七秒记忆的鱼，你每次都得重新向它介绍自己。

那么，我们该如何解决HTTP的“健忘症”，让服务器能够“记住”用户的登录状态呢？

## 传统方案的挣扎：基于Session的认证

传统的解决方案是使用**Session（会话）**。它的工作流程大致如下：

1.  **用户登录**：用户提供用户名和密码。
2.  **服务器验证**：服务器验证凭证无误。
3.  **创建Session**：服务器在内存（或数据库/缓存）中为该用户创建一个Session记录，并生成一个唯一的`Session ID`。
4.  **返回Cookie**：服务器将这个`Session ID`通过HTTP响应头中的`Set-Cookie`字段，发送给用户的浏览器。
5.  **后续请求**：浏览器在后续的每次请求中，都会自动携带包含`Session ID`的Cookie。
6.  **服务器校验**：服务器接收到请求后，从Cookie中提取`Session ID`，然后在自己的Session存储中查找对应的用户信息。如果找到了，就确认了用户的身份。

这个模型在很长一段时间里都工作得很好。但随着我们的VibeVault系统变得越来越复杂，特别是当我们准备迈向分布式、可扩展的云端架构时，它的弊端就暴露无遗了。

**Session方案的困境（The Struggle）**

想象一下，为了应对大量的用户访问，我们将VibeVault部署在了**多台服务器**上，前面用一个负载均衡器来分发请求。

*   **问题出现**：用户第一次登录请求被负载均衡器路由到了**服务器A**。服务器A验证成功，在自己的内存中创建了Session。
*   用户发出的第二个请求（例如，获取播放列表），被负载均衡器路由到了**服务器B**。
*   服务器B收到了请求和`Session ID`，但它在自己的内存中找不到这个ID对应的Session信息！因为它是由服务器A创建的。
*   **结果**：在服务器B看来，这个用户是未登录的。用户体验会非常糟糕，可能会被频繁要求重新登录。

为了解决这个问题，工程师们发明了一些方案，比如**Session粘滞（Sticky Sessions）**，让同一个用户的请求总是被路由到同一台服务器。但这牺牲了负载均衡的灵活性。更通用的方案是**Session共享**，即将所有服务器的Session信息集中存储到一个地方，比如Redis或Memcached数据库。但这又引入了新的复杂性和依赖，我们的认证系统变得**有状态（Stateful）**了，系统的可扩展性和维护成本都增加了。

我们需要一种更优雅、更现代、更适合分布式系统的方案。

## 顿悟：JWT - 自包含的身份凭证

这就是**JWT (JSON Web Token)** 登场的时刻。JWT的革命性在于，它提出了一种**无状态（Stateless）**的认证方案。

JWT的本质不是一个随机的ID，而是一个**自包含的（Self-contained）、经过加密签名的JSON对象**。这意味着所有验证用户身份所需的信息，都包含在这个Token本身之中。服务器不再需要自己存储任何Session信息。

让我们看看JWT是如何解决多服务器问题的：

1.  **用户登录**：用户提供用户名和密码。
2.  **服务器验证与签发Token**：服务器验证凭证无误后，将用户的核心信息（如用户ID、角色等）和过期时间等打包成一个JSON对象（Payload），然后用一个只有服务器自己知道的**密钥（Secret Key）**对其进行签名，生成一个JWT。
3.  **返回Token**：服务器将这个JWT返回给客户端。
4.  **客户端存储**：客户端（例如浏览器）将JWT存储起来（通常在`LocalStorage`或`HttpOnly Cookie`中）。
5.  **后续请求**：在后续的每次请求中，客户端都需要在HTTP请求头（通常是`Authorization`头）中附上这个JWT。
6.  **任意服务器校验**：任何一台服务器收到请求后，都可以从请求头中获取JWT。它**不需要查询任何地方**，只需要用自己保存的那个相同的**密钥（Secret Key）**来验证JWT的签名是否有效。如果签名有效，说明这个Token确实是我们的服务器签发的，且没有被篡改。然后，服务器就可以安全地从JWT的Payload中解析出用户信息，从而确认用户的身份和权限。

![JWT vs Session](https://i.imgur.com/7Q4V1iG.png)

因为验证Token所需的一切信息（签名密钥）所有服务器都有，所以请求无论被路由到哪台服务器，都能被正确处理。认证逻辑变得**无状态**，我们的系统因此获得了极佳的水平扩展能力，完美适应了微服务和移动应用的现代架构。

### JWT的结构

一个JWT看起来像一长串无意义的字符，但它实际上由三部分组成，用点（`.`）分隔：

`xxxxx.yyyyy.zzzzz`

1.  **Header (头部)**: 通常包含两部分信息：令牌的类型（即`JWT`）和所使用的签名算法（如`HS256`或`RS256`）。这部分会经过Base64Url编码。
2.  **Payload (载荷)**: 包含了**声明（Claims）**，是关于实体（通常是用户）和附加元数据的语句。这里存放着我们想要传递的数据，如用户ID、用户名、角色、过期时间等。**注意：Payload是明文的（只经过了Base64Url编码），所以绝对不要在里面存放任何敏感信息，比如用户的密码！**
3.  **Signature (签名)**: 这是JWT安全性的关键。为了创建签名部分，你必须获取编码后的Header、编码后的Payload、一个密钥（secret），使用Header中指定的算法进行签名。例如，如果使用HS256算法，签名将通过以下方式创建：
    ```
    HMACSHA256(
      base64UrlEncode(header) + "." +
      base64UrlEncode(payload),
      secret)
    ```
    这个签名用于验证消息在传递过程中没有被篡改，并且，在对称加密的情况下，它还可以验证JWT的发送者是谁。

---

## Vibe Check (思考与练习)

1.  **思考**: 如果你的网站部署在多台服务器上，用户第一次登录在服务器A，第二次请求却被路由到服务器B。如果使用传统的Session，服务器B如何知道用户已经登录了？JWT如何解决了这个问题？
2.  **AI协同**: 询问AI：“请解释JWT的结构（Header, Payload, Signature）以及每个部分的含义。为什么Signature是JWT安全性的关键？”
3.  **安全思考**: JWT虽然方便，但它也有其安全风险，例如令牌泄露。你认为应该如何存储JWT在客户端（浏览器）？为什么？（提示：LocalStorage vs. HttpOnly Cookie）。 