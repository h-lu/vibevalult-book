# 2.0 - Git 入门：代码的时光机

> "前事不忘，后事之师。"

::: {.video-container}
<iframe src="https://player.bilibili.com/player.html?bvid=BV1QvnwzfEFA&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="400"></iframe>
:::

## 本节危机：我的代码昨天还是好的！

在上一章，我们成功地初始化了 `VibeVault` 项目，它能够运行，能够通过测试，我们甚至还引入了 `Gson` 库。这是一个完美的开端。但一个幽灵般的问题开始浮现：

- 如果我为了尝试一个新功能，改了5个文件，结果发现想法是错的，该如何"撤销"这5个文件的所有修改？
- 如果我的代码今天还能正常工作，明天加了一个新功能后就崩溃了，我如何能精确地知道我昨天和今天代码的"区别"？
- 当项目越来越复杂，我们如何安全地保存每一个"里程碑"式的版本，以便随时可以回溯？

没有版本控制，我们的项目就像是建在沙滩上的城堡，任何一次错误的修改都可能让它毁于一旦。**我们面临的危机是：如何为我们的代码建立一个可靠的"存档"和"撤销"机制，让我们可以大胆地向前探索，同时拥有随时回到过去的"超能力"？**

## 本节顿悟：Git，代码的终极"存档"大法

答案就是 **Git**。Git 是一个分布式版本控制系统，我们可以将它理解为一台为代码量身定做的"时光机"。

它不仅仅是保存文件的副本，而是以"快照"（Commit）的形式，记录下你每一次有意义的修改。更强大的是，它引入了"平行宇宙"的概念——**分支（Branch）**。你可以在一个独立的宇宙里尽情实验，成功了，就将它合并回主宇宙；失败了，就将这个平行宇宙直接抛弃，主宇宙的代码丝毫不受影响。

**顿悟在于：我们应该像玩游戏一样频繁"存档"我们的代码。** 每完成一个小功能，就创建一个"存档点"（Commit）。在进行大的改动前，就开启一个"新的冒险线"（Branch）。这不仅给了我们无限的后悔药，也让我们的开发历史变得清晰可追溯。

## 准备工作：安装 Git

如果你在第一章的工具准备环节中尚未安装 Git，请先完成安装：

- **官方网站**: [https://git-scm.com/downloads](https://git-scm.com/downloads)
- **中国镜像**: [https://registry.npmmirror.com/binary.html?path=git-for-windows/](https://registry.npmmirror.com/binary.html?path=git-for-windows/)

根据你的操作系统（Windows, macOS, or Linux）选择对应的版本进行安装。安装完成后，在终端中运行 `git --version` 确认安装成功。

---

## 1. Git 基础：理解三个区域与首次提交

在使用 Git 之前，我们需要理解 Git 的核心工作模型。Git 将你的项目分为三个"区域"：

### Git 的三区模型

```
┌─────────────┐    git add    ┌─────────────┐   git commit   ┌─────────────┐
│  工作区      │  ──────────>  │  暂存区      │  ───────────>  │  版本库      │
│ Working Dir │               │ Staging Area│                │ Repository  │
│ (你的文件夹)  │               │ (准备提交)    │                │ (.git目录)   │
└─────────────┘               └─────────────┘                └─────────────┘
```

- **工作区（Working Directory）**：你实际编辑文件的地方，就是你在电脑上看到的项目文件夹。
- **暂存区（Staging Area）**：一个"中转站"，用来精心挑选你想要提交的修改。这让你可以分批次、有选择地提交代码。
- **版本库（Repository）**：存储在 `.git` 目录中的所有历史记录和版本快照。

> **为什么要有暂存区？** 想象你修改了5个文件，但只有3个文件的修改是相关的，应该作为一个"功能"提交。暂存区让你可以只将这3个文件添加到下一次提交中，而保留另外2个文件的修改继续开发。

### 初始化仓库

现在，让我们为 `VibeVault` 项目注入版本控制的灵魂。打开终端，确保你位于项目根目录下：

```bash
# 初始化Git仓库
git init
```

这个命令会在你的项目下创建一个隐藏的 `.git` 目录——这就是你的"时光机"本体。

### 定义忽略规则：`.gitignore`

执行 `git status` 命令，你会看到 Git 把项目里所有的文件都列了出来。但我们并不想追踪所有文件。像 `build` 目录下的编译产物，或者 `.gradle` 目录下的缓存，它们都是可以被重新生成的临时文件，不应该进入版本历史。

在项目根目录下创建 `.gitignore` 文件，并填入以下内容：

```gitignore
# Gradle 构建产物和缓存
.gradle
build/

# Gradle 配置
gradle-app.setting

# 保留 Gradle Wrapper（重要！）
!gradle-wrapper.jar
!gradle/wrapper/gradle-wrapper.properties

# 其他缓存
.gradletasknamecache
```

再次运行 `git status`，你会发现 `build` 和 `.gradle` 目录已经从列表中消失了。

### 创建第一个提交（Commit）

现在，让我们拍摄项目的第一张"历史快照"：

```bash
# 第一步：将所有未被忽略的文件添加到暂存区
git add .

# 第二步：查看暂存区的状态（可选，但建议养成习惯）
git status

# 第三步：提交暂存区的内容到版本库
git commit -m "Initial commit of VibeVault project"
```

让我们解析这些命令的含义：

- **`git add .`**：将当前目录（`.`）下所有修改过的文件添加到暂存区。你也可以用 `git add <文件名>` 来只添加特定文件。
- **`git status`**：查看当前工作区和暂存区的状态，这是你最常用的命令之一。
- **`git commit -m "..."`**：将暂存区的内容提交到版本库，`-m` 后面是提交信息（commit message）。

> **提交信息的艺术**：好的提交信息应该简洁地描述"做了什么"，例如 `"添加用户注册功能"` 而不是 `"修改了代码"`。养成写清晰提交信息的习惯，未来的你会感谢现在的你。

### 查看历史记录

恭喜！你已经创建了第一个提交。运行以下命令查看提交历史：

```bash
# 查看详细历史
git log

# 查看简洁的单行历史（推荐）
git log --oneline
```

你会看到类似这样的输出：

```
a1b2c3d (HEAD -> main) Initial commit of VibeVault project
```

这里的 `a1b2c3d` 是提交的哈希值（实际上更长，这里显示的是简短版本），它是这个提交在时间线上的唯一"坐标"。

---

## 2. 分支：平行宇宙的力量

### 为什么需要分支？

想象一下：你正在主分支上开发一个新功能，写到一半时，突然需要紧急修复一个严重的 bug。如果没有分支，你有两个糟糕的选择：

1. 提交半成品代码（破坏了项目稳定性）
2. 先不提交，直接在半成品基础上修 bug（代码会变得一团糟）

**分支解决了这个问题。** 它让你可以：

- 在一个独立的"平行宇宙"中开发新功能，不影响主线代码
- 随时切换到主分支去修复 bug
- 功能开发完成后，再将分支合并回主线

### 本书的章节学习工作流

在本书中，我们将采用一个简单而强大的分支策略：

- **`main` 分支**：作为我们的"黄金主线"，只存放每个章节最终完成的、稳定的代码。
- **`ch02`、`ch03` 等分支**：每一章的开发过程都在专门的分支上进行。

这样做的好处是：

- **隔离性**：你在 `ch02` 分支上的任何修改，都不会影响到 `main` 分支。
- **清晰性**：每个分支清晰地对应一章的内容，让项目的演进历史一目了然。
- **安全性**：`main` 分支永远是你"确定能用"的版本。

### 创建并切换分支

现在，让我们为第二章的学习创建一个新分支：

```bash
# 创建名为 ch02 的新分支
git branch ch02

# 切换到 ch02 分支
git switch ch02

# 或者用一条命令完成创建和切换
git switch -c ch02
```

> **注意**：较旧的 Git 版本使用 `git checkout -b ch02` 来创建并切换分支。`git switch` 是 Git 2.23 引入的新命令，语义更清晰。

运行 `git branch` 可以查看所有分支，当前分支前会有一个 `*` 标记：

```
* ch02
  main
```

现在，你已经身处 `ch02` 这个"平行宇宙"了。从现在起，你在本章的所有编码、修改、提交，都将记录在 `ch02` 分支上。

### 章节学习的完整循环

在接下来的学习中，你将不断重复这个模式：

**1. 开始新章节**（例如第3章）：

```bash
# 切换回主分支
git switch main
# 为第3章创建并切换到新分支
git switch -c ch03
```

**2. 在分支上学习和编码**：

```bash
# 修改代码...
git add .
git commit -m "完成了xxx功能"
# 继续修改...
git add .
git commit -m "添加了yyy测试"
# 重复...
```

**3. 完成章节，合并成果**：

```bash
# 切换回主分支
git switch main
# 将 ch03 分支的全部成果合并到 main 分支
git merge ch03
```

这个简单的工作流将贯穿我们整个学习旅程，让你在不知不觉中成为一名专业的"代码时空旅行者"。

---

## 3. 日常操作：查看状态与历史

在日常开发中，你需要频繁地查看项目的状态和历史。掌握这些命令能让你始终清楚"我在哪里，我改了什么"。

### 查看当前状态

```bash
git status
```

这是你最常用的命令之一。它会告诉你：

- 当前在哪个分支
- 哪些文件被修改了
- 哪些文件在暂存区
- 哪些文件还未被追踪

**养成习惯**：在每次 `git add` 之前和之后都运行一次 `git status`，确认你要提交的内容。

### 查看提交历史

```bash
# 查看详细的提交历史
git log

# 查看简洁的单行历史（推荐）
git log --oneline

# 查看带有分支图的历史（可视化分支结构）
git log --oneline --graph --all

# 查看最近 5 次提交
git log --oneline -5
```

### 查看文件差异

```bash
# 查看工作区相对于暂存区的修改
git diff

# 查看暂存区相对于上次提交的修改
git diff --staged

# 查看某个文件的修改
git diff <文件名>
```

**使用场景**：在提交前运行 `git diff --staged`，仔细检查你即将提交的内容，避免提交不必要的修改或敏感信息。

### 实践建议

养成以下工作节奏：

1. **修改代码前**：`git status` 确认工作区干净
2. **修改代码后**：`git diff` 查看修改内容
3. **准备提交前**：`git add .` → `git status` 确认暂存内容
4. **提交前最后检查**：`git diff --staged` 仔细审查
5. **提交**：`git commit -m "清晰的提交信息"`
6. **提交后**：`git log --oneline` 确认提交成功

---

## 4. 时光机技能：版本回退与恢复

Git 最强大的能力之一，就是让我们能够自由地在不同的时间点之间穿梭。当你发现当前的修改出了问题，或者想要撤销某些提交，你需要掌握"时光倒流"的技能。

### 理解 HEAD 指针

在 Git 中，**`HEAD`** 是一个特殊的指针，它始终指向你当前所在的提交（commit）。你可以把它想象成"你现在站在时间线的哪个位置"。

- `HEAD`：当前提交
- `HEAD~1` 或 `HEAD^`：当前提交的上一个提交（父提交）
- `HEAD~2`：往前数第二个提交
- `HEAD~n`：往前数第 n 个提交

理解 HEAD 是掌握版本回退的关键。

### 三种回退场景

Git 提供了 `git reset` 命令来回退版本，它有三种模式，对应三种不同的使用场景：

| 模式 | 命令 | 工作区 | 暂存区 | 版本库 | 使用场景 |
|------|------|--------|--------|--------|----------|
| `--soft` | `git reset --soft HEAD~1` | 保留 | 保留 | 回退 | 修改提交信息，合并多个提交 |
| `--mixed` | `git reset HEAD~1` | 保留 | 清空 | 回退 | 撤销提交，重新组织要提交的内容 |
| `--hard` | `git reset --hard HEAD~1` | 清空 | 清空 | 回退 | 完全放弃最近的修改，回到过去 |

#### 场景一：修改最后一次提交（`--soft`）

**问题**：你刚提交了一个 commit，但发现提交信息写错了，或者想再添加一些文件到这次提交中。

**解决方案**：

```bash
# 回退到上一个 commit，但保留所有修改
git reset --soft HEAD~1

# 修改文件或重新添加文件...
git add .

# 重新提交
git commit -m "正确的提交信息"
```

**效果**：就像"撤销"了最后一次提交，但所有代码修改都还在，你可以重新提交。

#### 场景二：撤销提交但保留修改（`--mixed`，默认）

**问题**：你提交了代码，但觉得这次提交包含的内容太多或太杂，想要重新组织。

**解决方案**：

```bash
# 回退到上一个 commit，保留工作区修改，但清空暂存区
git reset HEAD~1

# 现在你可以重新选择要提交的文件
git add <特定文件>
git commit -m "更合理的提交1"

git add <其他文件>
git commit -m "更合理的提交2"
```

**效果**：提交被撤销，代码修改还在工作区，你可以重新分批提交。

#### 场景三：完全回退（`--hard`，危险！）

**问题**：你确定最近的修改完全是错的，想要彻底抛弃它们，回到过去。

**解决方案**：

```bash
# 回退到上一个 commit，丢弃所有后续修改
git reset --hard HEAD~1

# 或回退到指定的 commit
git reset --hard a1b2c3d
```

> ⚠️ **警告**：`--hard` 会**永久删除**未提交的修改，请谨慎使用！在使用前，最好先用 `git stash` 保存当前修改，或者确认你真的不需要它们了。

**效果**：时光机倒流，一切回到指定的过去，中间的修改消失。

### 只读查看：`git checkout`

如果你只是想"看看"之前某个版本的代码，而不是真的要回退，可以使用：

```bash
# 切换到某个历史 commit（进入"分离 HEAD"状态）
git checkout a1b2c3d

# 查看或运行代码...

# 查看完毕后，切换回分支
git switch ch02
```

这不会改变任何历史，只是让你"时空旅行"到过去观察一下。

### 后悔药：`reflog` 救命机制

如果你不小心用 `git reset --hard` 删除了重要的 commit，不要慌张！Git 有一个"黑匣子"——`reflog`，它记录了 HEAD 的所有移动历史。

```bash
# 查看所有 HEAD 移动的历史记录
git reflog
```

你会看到类似这样的输出：

```
a1b2c3d (HEAD -> ch02) HEAD@{0}: reset: moving to HEAD~1
d4e5f6g HEAD@{1}: commit: 添加了用户类
h7i8j9k HEAD@{2}: commit: 完成基础配置
```

你可以使用 `HEAD@{n}` 或 commit 哈希值来恢复：

```bash
# 恢复到 reflog 中的某个状态
git reset --hard HEAD@{1}
```

这就是你的"终极后悔药"。即使误删了提交，只要是在本地操作的，reflog 都能帮你找回来（在一定时间内）。

### 实践演练

让我们在 `ch02` 分支上练习一下：

```bash
# 1. 做一些修改并提交
# （修改某个文件...）
git add .
git commit -m "实验性修改"

# 2. 查看历史
git log --oneline

# 3. 假设你想撤销刚才的提交但保留修改
git reset --soft HEAD~1

# 4. 查看状态，你会发现修改还在暂存区
git status

# 5. 重新提交或继续修改
git commit -m "改进后的版本"
```

记住：**在分支上实验是安全的。** 即使出错了，你的 `main` 分支依然是稳定的。

---

## 本章准备完成

到这里，你已经掌握了 Git 的核心技能：

✅ **理解 Git 的三区模型**：工作区、暂存区、版本库  
✅ **初始化项目**：`git init`、`.gitignore`、首次提交  
✅ **使用分支**：创建、切换、合并分支  
✅ **日常操作**：查看状态、历史、差异  
✅ **版本回退**：`reset` 的三种模式，`reflog` 救命机制

### Git 命令速查表

```bash
# 基础操作
git init                  # 初始化仓库
git status                # 查看状态
git add .                 # 添加所有修改到暂存区
git commit -m "信息"      # 提交
git log --oneline         # 查看历史

# 分支操作
git branch                # 查看所有分支
git switch -c <分支名>    # 创建并切换分支
git switch <分支名>       # 切换分支
git merge <分支名>        # 合并分支

# 查看差异
git diff                  # 工作区 vs 暂存区
git diff --staged         # 暂存区 vs 版本库

# 版本回退
git reset --soft HEAD~1   # 软回退（保留所有修改）
git reset HEAD~1          # 混合回退（保留工作区修改）
git reset --hard HEAD~1   # 硬回退（丢弃所有修改，危险！）
git reflog                # 查看 HEAD 历史（救命药）
```

### 接下来的学习

你现在应该已经位于 `ch02` 分支上了。在本章接下来的内容中，我们将开始学习**封装**的概念，设计新的 Java 类来管理歌曲数据。

请在 `ch02` 分支上完成这些工作，并练习使用 `git add` 和 `git commit` 来记录你的开发进度。记住：**频繁提交，清晰描述**。每完成一个小功能或修复一个小问题，就提交一次。

在第二章的最后，我们将一起实践第一次 `git merge` 操作，将你的学习成果合并回 `main` 分支，为第三章的学习做好准备。

**现在，让我们开始真正的编码冒险吧！** 🚀
