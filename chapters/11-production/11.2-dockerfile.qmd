# 11.2 打包应用：编写Dockerfile

如果说Docker镜像（Image）是一道菜，那么**Dockerfile**就是这道菜的**食谱 (Recipe)**。
它告诉Docker引擎：先放什么料，再煮多久，最后怎么装盘。

## 编写你的第一份食谱

在 `chapter-code/ch08` 根目录下（与 `build.gradle.kts` 同级），创建一个名为 `Dockerfile` 的文件（注意：没有后缀名，首字母大写）。

我们将逐行解析这份食谱：

```dockerfile
# 1. 基础镜像 (Base Image)
# 就像做菜需要底料。我们选择基于Alpine Linux的JDK 21。
# Alpine是一个极简的Linux发行版，体积只有5MB左右。
FROM eclipse-temurin:21-jdk-alpine

# 2. 维护者信息 (可选)
LABEL maintainer="vibecoder@example.com"

# 3. 设置工作目录 (Work Directory)
# 相当于在容器内部执行了 `cd /app`。后续命令都在这个目录下执行。
WORKDIR /app

# 4. 复制文件 (Copy)
# 将宿主机 build/libs 目录下的 jar 包复制到容器内的 /app 目录下，并重命名为 app.jar
# 注意：这需要你先在宿主机运行 ./gradlew bootJar
COPY build/libs/*.jar app.jar

# 5. 暴露端口 (Expose)
# 告诉使用者，这个容器里的应用会监听8080端口。
# 这只是一个声明，不会自动映射端口。
EXPOSE 8080

# 6. 启动命令 (Entrypoint)
# 容器启动时执行的命令。
# 相当于在终端输入 java -jar app.jar
ENTRYPOINT ["java", "-jar", "app.jar"]
```

## 深入理解：镜像分层 (Layer Caching)

Docker构建镜像时，不是一整块，而是像**千层饼**一样，一层层叠加的。
Dockerfile中的**每一行指令**，都会创建一个新的层（Layer）。

**为什么这很重要？** 因为**缓存**。

当你再次构建镜像时，Docker会检查每一层：

*   如果这一行的指令没变，且它依赖的文件也没变 -> **直接使用缓存**（极快）。
*   如果变了 -> **重新构建这一层及其之后的所有层**。

### 优化建议

在实际项目中，我们通常会把“不常变的东西”放在前面，把“常变的东西”放在后面。

*   **不常变**: 操作系统、JDK、第三方依赖库。
*   **常变**: 你的业务代码。

(进阶技巧：可以使用多阶段构建 `Multi-stage Build` 来进一步减小体积和利用缓存，这里暂不展开，先掌握基础。)

## 实战演练

1.  **构建Jar包**:

    ```bash
    ./gradlew bootJar
    ```
    *(确保看到了 `BUILD SUCCESSFUL`)*

2.  **构建镜像**:

    ```bash
    docker build -t vibevault-backend:v1 .
    ```
    *   `-t`: Tag，给镜像起名和打标签。
    *   `.`: Context，告诉Docker在当前目录下寻找文件（包括Dockerfile和要COPY的文件）。

3.  **查看成果**:

    ```bash
    docker images
    ```
    你应该能看到 `vibevault-backend` 出现在列表中，大小可能在300MB左右（JDK本身比较大）。

## Vibe Check

1.  **实验**: 修改你的Java代码（比如在Controller里改个日志），重新运行 `bootJar`，然后重新 `docker build`。观察终端输出。
    *   你会发现 `FROM`, `WORKDIR` 等步骤显示 `Using cache`。
    *   只有 `COPY` 和 `ENTRYPOINT` 步骤重新执行了。这就是分层缓存的魔力。

2.  **思考**: 为什么我们不把源代码 (`src/`) 复制进去，然后在容器里运行 `gradle build`？
    *   (提示：生产环境需要Gradle吗？需要源代码吗？镜像越小越安全。)
