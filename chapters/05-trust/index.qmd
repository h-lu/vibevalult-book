---
title: "第五章：从“能跑”到“可靠”：为代码建立信任"
---

> "如果你的代码没有测试，那它就是坏的。我不是说它写得很烂，我的意思是它坏了——它无法正常工作。" - Michael Feathers

## 本章危机

我们的VibeVault应用功能越来越丰富，代码也越来越多。现在，如果我们想给`Playlist`类添加一个新功能，或者想重构`saveToFile`方法的逻辑，我们会感到一阵**恐惧**。

我们怎么能确定，我们的修改没有“破坏”任何现有的功能？难道每次修改后，都要手动启动程序，把所有功能都点一遍吗？这种依赖于“手动验证”的信任是脆弱的、不可靠的，并且随着项目变大，成本会急剧上升，最终让我们完全不敢再碰任何代码。

**我们面临的危机是：缺乏一种高效、可靠、自动化的方式来验证代码的正确性，导致我们对自己的代码失去了“信任”。**

## 本章顿悟

我们需要将“验证”这个动作本身，也变成代码。这种“用来测试代码的代码”，就是**自动化测试**。它为我们的项目构建了一张不知疲倦、覆盖全面的“安全网”。每当我们做出任何修改，只需运行一下测试，如果安全网没有“破洞”（测试全部通过），我们就能极大地增强信心，相信我们的修改是安全的。

在本章中，我们将直面软件熵的无情力量，学习如何通过自动化测试来构建对代码的“信任”。这是从业余项目迈向专业工程的关键一步。我们将：

1.  **[为何需要测试？](./01-why-test.qmd)**: 从第一性原理出发，理解“手动验证”的不可靠性，以及自动化测试作为对抗软件复杂性的核心武器的必要性。
2.  **[搭建测试实验室](./02-setup-lab.qmd)**: 使用现代Gradle的`testing.suites`配置JUnit 5，并通过为`Playlist`添加getter方法，迈出“可测试性”的第一步。
3.  **[精确的断言语言](./03-assertion-language.qmd)**: 学习使用AssertJ的流畅接口，让我们的测试代码像自然语言一样清晰、易读地表达“期望”。
4.  **[伪造现实：Mockito的when-thenReturn](./04-faking-reality.qmd)**: 学习使用Mockito打桩(Stubbing)，控制外部依赖的返回值，从而测试依赖“外部输入”的方法。
5.  **[验证行为：Mockito的verify](./05-verifying-actions.qmd)**: 学习使用Mockito验证(Verification)，检查代码是否正确地调用了其依赖项，从而测试“没有返回值”或“核心职责是调用其他方法”的方法。

完成本章后，你将拥有一套强大的自动化测试工具和思想，让你有信心、有勇气去持续地改进和重构你的代码。 