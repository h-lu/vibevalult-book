---
title: "2.4 - 签订契约：用AI能懂的语言绘制蓝图"
---

> “在我看来，语言是我们最取之不尽的魔法源泉。” —— 阿不思·邓布利多

## 本节危机：AI有时像个“糊涂”的实习生

我们拥有了强大的AI编程伙伴，它可以为我们生成代码。但如果我们直接对它说：“嘿，给我写一个处理播放列表的Java类”，结果可能会五花八门。AI可能会生成一个只有歌曲标题的列表，也可能会包含一大堆我们根本不需要的复杂功能。

就像与一位实习生合作，如果你不给他一份清晰的需求规格说明书，他可能会凭着自己的想象力（和网上搜到的代码）交付一个完全不符合你期望的东西。代码一旦被生成，再去修改它的结构，往往比推倒重来还要费劲。

**我们面临的危机是：如何精确、无歧"地向AI传达我们的设计意图，确保它能一次性生成结构正确、符合我们期望的代码“骨架”？**

## 本节顿悟：像建筑师一样，先给AI一份UML蓝图

答案是，在让AI“施工”（写代码）之前，我们先为它提供一份清晰的“建筑蓝图”。在软件工程领域，这份蓝图就是**UML（统一建模语言）**。

传统的UML需要用专门的图形软件绘制，分享和版本管理都很麻烦。但在现代开发实践中，我们有了更好的选择：**用纯文本来描述UML**。这就是像 **Mermaid** 这样的工具大放异彩的地方。

Mermaid允许我们用非常直观的文本语法来定义UML图表。这份纯文本的“蓝图”对AI来说是完美的输入：

1.  **精确无歧义**：它清晰地定义了类、属性、类型和它们之间的关系。
2.  **机器可读**：AI可以轻松解析这段文本，并准确地将其翻译成任何编程语言的代码结构。
3.  **易于版本控制**：我们可以像管理源码一样，用Git来追踪我们“蓝图”的每一次修改。

**顿悟在于：我们不应将AI视为一个无所不能的黑盒，而是一个需要清晰指令的强大“代码生成引擎”。通过提供Mermaid定义的UML类图作为“契约”，我们就能驾驭AI，让它成为我们高效、可靠的“代码建筑师”。**

---

## 1. 定义我们的核心“契约”

现在，让我们运用在行业最佳实践（Spotify API）中学到的知识，为 `VibeVault` 的两个核心概念——`Song` 和 `Playlist`——定义它们的“契约”。

我们将使用Mermaid的 `classDiagram` 语法来绘制这份蓝图。

```{{mermaid}}
classDiagram
    class Song {
        -String id
        -String title
        -String artist
        -String album
        -int durationInSeconds
        +getId() String
        +getTitle() String
        +getArtist() String
        +getAlbum() String
        +getDurationInSeconds() int
    }

    class Playlist {
        -String id
        -String name
        -String description
        -List~Song~ tracks
        +getId() String
        +getName() String
        +getDescription() String
        +getTracks() List~Song~
        +addSong(Song song) void
        +removeSong(Song song) void
    }

    Playlist "1" -- "0..*" Song : contains
```

让我们来解读这份“蓝图”：

- **`class Song`** 和 **`class Playlist`**: 定义了两个类。
- **`-String id`**: 定义了一个私有（`-`号代表`private`）属性`id`，它的类型是`String`。
- **`+getId() String`**: 定义了一个公开（`+`号代表`public`）方法`getId()`，它返回一个`String`。
- **`List~Song~ tracks`**: 定义了一个列表类型的属性`tracks`，列表中的元素都是`Song`对象。`~`符号用于分隔泛型类型。
- **`Playlist "1" -- "0..*" Song : contains`**: 这定义了两个类之间的关系。一个`Playlist`（`"1"`）可以包含（`contains`）零个或多个（`"0..*"`）`Song`对象。这正是“聚合”的体现！

这份Mermaid代码不仅是一张清晰的图表（在支持Mermaid的编辑器中会自动渲染），更是一份可以复制、粘贴、直接交给AI的精确指令。

## 2. 将“蓝图”交给AI建筑师

现在，最神奇的时刻到来了。我们可以直接将上面的Mermaid代码块交给我们的AI伙伴，并给出这样的指令（Prompt）:

> **AI Prompt 示例:**
>
> 你好，你是一位精通领域驱动设计（DDD）和Java编程的专家。请根据以下Mermaid格式的UML类图，为我生成对应的Java POJO（Plain Old Java Object）类。
>
> **设计要求:**
>
> 1.  严格遵循类图中的属性名和类型。
> 2.  所有属性都应为私有（private）。
> 3.  为每个属性生成公开的（public）getter方法。
> 4.  为 `Playlist` 类中的 `tracks` 属性进行初始化，确保它在对象创建时是一个空的列表，避免空指针异常。
> 5.  `addSong` 和 `removeSong` 方法需要实现基本的添加和移除逻辑。
> 6.  请为每个类添加一个无参构造函数。
> 7.  遵循标准的Java命名规范。
>
> 这是UML蓝图：
>
> ```mermaid
> classDiagram
>     class Song {
>         -String id
>         -String title
>         -String artist
>         -String album
>         -int durationInSeconds
>     }
>
>     class Playlist {
>         -String id
>         -String name
>         -String description
>         -List~Song~ tracks
>         +addSong(Song song) void
>         +removeSong(Song song) void
>     }
>
>     Playlist "1" -- "0..*" Song : contains
> ```

通过这样一个结构清晰、要求明确的Prompt，AI几乎可以完美地生成我们所需要的Java代码。它不再是猜测，而是在我们定义的“契约”下进行精确的“代码翻译”。

## Vibe Check (思考与练习)

1.  **扩展你的蓝图**:
    `Song`类目前的信息还比较基础。请参考我们之前调研的Spotify `Track`对象，为`Song`类至少增加3个你认为有用的属性（例如`popularity`, `isExplicit`等）。
    *   首先，修改上面的Mermaid `classDiagram`代码，在`Song`类中添加新的私有属性和对应的公开getter方法。
    *   然后，将你修改后的Mermaid代码和需求，作为新的Prompt交给AI，看看它是否能为你更新Java代码。

2.  **AI协同**:
    将你新生成的 `Song.java` 和 `Playlist.java` 文件的代码完整地复制给AI，然后向它提问：
    > "你好，这是我项目中两个核心的实体类。请你扮演一位代码审查专家，从封装、命名和健壮性的角度，评估一下我的代码。有没有什么可以改进的地方？特别是对于`Playlist`类中的`tracks`列表，直接返回它本身是否是最佳实践？为什么？"

这个练习将引导你思考超越“代码生成”本身的问题，开始关注代码质量和设计原则。这正是从“代码使用者”向“代码设计者”转变的关键一步。
