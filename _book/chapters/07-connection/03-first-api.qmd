---
title: "构建你的第一个API"
---

> "千里之行，始于足下。" - 老子

## 本节危机：万事俱备，如何连接？

我们拥有了：
*   一个健壮的三层架构（`Controller`, `Service`, `Repository`）。
*   一个强大的Web服务器（由Spring Boot提供的嵌入式Tomcat）。

但它们现在是分离的。Spring Boot不知道我们的`PlaylistController`应该去处理Web请求。我们的`PlaylistServiceImpl`也不知道应该由Spring Boot来创建和管理。我们手动`new`出来的对象，游离在Spring的“控制”之外。

**我们面临的危机是：如何将我们自己编写的业务组件，“注册”到Spring容器中，并将其与外部的HTTP请求“连接”起来？**

## 本节顿悟：注解——给Spring的“指令”

Spring Boot通过**注解 (Annotations)** 来解决这个问题。注解就像是我们贴在类或方法上的“标签”，Spring Boot在启动时会扫描这些标签，并根据标签的指示来做事。

### 核心注解

*   `@Component`: 最基础的标签，告诉Spring：“请创建这个类的实例，并由你来管理它。”这个实例被称为一个**Bean**。
*   `@Repository`: `@Component`的特殊化。贴在数据访问层（DAO）的类上，告诉Spring：“这是一个数据访问的Bean。”（它还能提供额外的数据库异常转译功能）。
*   `@Service`: `@Component`的特殊化。贴在业务逻辑层的类上，告诉Spring：“这是一个业务逻辑的Bean。”
*   `@RestController`: `@Controller`和`@ResponseBody`的组合。贴在表现层的类上，告诉Spring：“这是一个处理HTTP请求的控制器Bean，并且它的所有方法的返回值，都应该被自动序列化成JSON格式，直接写入HTTP响应体。”

### 依赖注入：`@Autowired`

当我们把所有类都交给Spring管理后，我们不再需要手动`new`对象了。我们只需要在需要依赖的地方，声明一个构造函数即可，Spring会自动找到对应的Bean，并“注入”进来。这就是“控制反转”和“依赖注入”的魔力。

现在，让我们动手将所有零件连接起来！

---

## Vibe Check (动手与思考)

### 第一步：让Spring管理我们的组件

我们将为第六章创建的类，贴上正确的“标签”。

1.  **Repository层**

    ```java
    // In: src/main/java/com/vibevault/repository/FilePlaylistRepository.java
    package com.vibevault.repository;

    import com.vibevault.model.Playlist;
    import com.vibevault.model.Song;
    import org.springframework.stereotype.Repository;
    // ... other imports

    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import java.util.List;

    @Repository // <--- 添加标签
    public class FilePlaylistRepository implements PlaylistRepository {
        private static final String DATA_DIRECTORY = "data";

        @Override
        public void save(Playlist playlist) {
            Path path = Paths.get(DATA_DIRECTORY, playlist.getName() + ".csv");
            List<String> csvLines = playlist.getSongs().stream()
                .map(song -> String.format("%s,%s,%d", song.title(), song.artist(), song.durationInSeconds()))
                .toList();

            try {
                Files.createDirectories(path.getParent());
                Files.write(path, csvLines);
            } catch (IOException e) {
                System.err.println("❌ 错误：无法保存播放列表到 " + path);
                e.printStackTrace();
            }
        }

        @Override
        public Playlist load(String playlistId) {
            Path path = Paths.get(DATA_DIRECTORY, playlistId + ".csv");
            Playlist playlist = new Playlist(playlistId);

            if (Files.notExists(path)) {
                System.out.println("ℹ️ 提示：播放列表文件 " + path + " 不存在。");
                return playlist; // 返回一个以此id命名的空播放列表
            }

            try {
                List<String> csvLines = Files.readAllLines(path);
                for (String line : csvLines) {
                    String[] fields = line.split(",");
                    if (fields.length == 3) {
                        playlist.addSong(new Song(fields[0], fields[1], Integer.parseInt(fields[2])));
                    }
                }
            } catch (IOException | NumberFormatException e) {
                System.err.println("❌ 错误：无法从 " + path + " 加载播放列表。");
                e.printStackTrace();
            }
            return playlist;
        }
    }
    ```

2.  **Service层**
    
    ```java
    // In: src/main/java/com/vibevault/service/PlaylistServiceImpl.java
    package com.vibevault.service;

    import com.vibevault.dto.PlaylistDTO;
    import com.vibevault.dto.SongDTO;
    import com.vibevault.model.Playlist;
    import com.vibevault.model.Song;
    import com.vibevault.repository.PlaylistRepository;
    import org.springframework.stereotype.Service;
    // ... other imports

    import java.util.List;
    import java.util.stream.Collectors;
    import com.vibevault.exception.ResourceNotFoundException;

    @Service // <--- 添加标签
    public class PlaylistServiceImpl implements PlaylistService {
        private final PlaylistRepository repository;

        public PlaylistServiceImpl(PlaylistRepository repository) {
            this.repository = repository;
        }
        
        @Override
        public PlaylistDTO getPlaylistById(String id) {
            Playlist playlist = repository.load(id);
            if (playlist.getSongs().isEmpty() && Files.notExists(Paths.get("data", id + ".csv"))) { // 更精确的判断
                 throw new ResourceNotFoundException("Playlist not found with id: " + id);
            }

            List<SongDTO> songDTOs = playlist.getSongs().stream()
                .map(song -> new SongDTO(song.title(), song.artist()))
                .collect(Collectors.toList());
            return new PlaylistDTO(playlist.getName(), songDTOs);
        }

        @Override
        public void addSong(String playlistId, Song song) {
            Playlist playlist = repository.load(playlistId);
            playlist.addSong(song);
            repository.save(playlist);
        }
    
        @Override
        public void removeSong(String playlistId, int songIndex) {
            Playlist playlist = repository.load(playlistId);
            // 注意，API层面接收的可能是1-based index，需要转换为0-based
            playlist.removeSong(songIndex - 1);
            repository.save(playlist);
        }
    
        @Override
        public String listSongs() {
            // 这个方法将被废弃，由返回DTO的方法替代
            return "This method is deprecated.";
        }
    
        @Override
        public void saveData() {
            // This method is no longer needed as save is handled by repository
        }
        // ... class content might have more methods
    }
    ```
    *注意：我们已经彻底移除了在Service层缓存`Playlist`对象的做法，也删除了在构造函数里加载默认数据的逻辑。现在，每一次请求都将通过Repository与数据源进行交互，这是更无状态、更健壮的设计。*

### 第二步：创建API端点

现在来改造我们的`PlaylistController`，让它成为一个真正的Web控制器。

1.  **删除旧的UI逻辑**：删除`ui`包下的`PlaylistController`，因为它包含的是命令行的`Scanner`逻辑。
2.  **创建新的Web控制器**: 在`com.vibevault`下创建一个新的包`controller`，并在其中创建新的`PlaylistController.java`。

    ```java
    // In: src/main/java/com/vibevault/controller/PlaylistController.java
    package com.vibevault.controller;

    import com.vibevault.dto.PlaylistDTO;
    import com.vibevault.service.PlaylistService;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PathVariable;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;

    @RestController // <--- 关键标签：声明这是一个RESTful控制器
    @RequestMapping("/api/playlists") // <--- 声明这个控制器下所有API的URL前缀
    public class PlaylistController {

        private final PlaylistService playlistService;

        // Spring会自动注入Service Bean
        public PlaylistController(PlaylistService playlistService) {
            this.playlistService = playlistService;
        }

        // 之前的方法，将被下面的DTO方法替代
        // @GetMapping 
        // public String getAllPlaylists() {
        //     return playlistService.listSongs();
        // }
    }
    ```

### 第三步：添加应用启动初始化逻辑 (最佳实践)

为了让我们的API在第一次启动时就有数据可供查看，我们将使用 `CommandLineRunner`。这是一个函数式接口，Spring Boot会在应用启动完成后，自动执行所有被注册为Bean的`CommandLineRunner`。

修改我们的主启动类：
```java
// In: src/main/java/com/vibevault/VibeVaultApplication.java
package com.vibevault;

import com.vibevault.model.Playlist;
import com.vibevault.model.Song;
import com.vibevault.repository.PlaylistRepository;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;

import java.nio.file.Files;
import java.nio.file.Paths;

@SpringBootApplication
public class VibeVaultApplication {

    public static void main(String[] args) {
        SpringApplication.run(VibeVaultApplication.class, args);
    }

    @Bean // <--- 将这个CommandLineRunner注册为Bean
    public CommandLineRunner initData(PlaylistRepository repository) {
        return args -> {
            final String defaultPlaylistId = "my-favorites";
            if (Files.notExists(Paths.get("data", defaultPlaylistId + ".csv"))) {
                System.out.println("ℹ️ 默认播放列表不存在，正在创建示例数据...");
                Playlist playlist = new Playlist(defaultPlaylistId);
                playlist.addSong(new Song("Bohemian Rhapsody", "Queen", 355));
                playlist.addSong(new Song("Stairway to Heaven", "Led Zeppelin", 482));
                repository.save(playlist);
                System.out.println("✅ 示例数据创建完毕！");
            }
        };
    }
}
```

### 第四步：验证！

现在，重新启动你的`VibeVaultApplication`。在控制台，你应该会看到我们添加的“正在创建示例数据”的日志。

应用成功启动后，打开你的浏览器，访问地址：
`http://localhost:8080/api/playlists/my-favorites`

**见证奇迹的时刻到了！** 你会看到一个结构清晰的JSON对象，其中包含了我们刚刚通过`CommandLineRunner`自动创建的两首歌曲。

### 第五步：最佳实践 - 使用DTO和路径变量

直接返回字符串或整个领域对象是一种不好的实践。API的契约应该是稳定的，并且应该能精确地定位资源。

为此，我们将结合使用**DTO (Data Transfer Object)** 和 **路径变量 (Path Variable)**。

1.  **创建DTO包和类**:
    *   在`com.vibevault`下创建新包`dto`。
    *   在`dto`包下创建`SongDTO.java`和`PlaylistDTO.java`。

    ```java
    // In: src/main/java/com/vibevault/dto/SongDTO.java
    package com.vibevault.dto;

    public record SongDTO(String title, String artist, int durationInSeconds) {
    }
    
    // In: src/main/java/com/vibevault/dto/PlaylistDTO.java
    package com.vibevault.dto;

    import java.util.List;

    public record PlaylistDTO(String name, List<SongDTO> songs) {
    }
    ```
    *注意：我们只暴露了`title`和`artist`，隐藏了`durationInSeconds`这个内部实现细节。*

2.  **在Service层进行转换**: 修改`PlaylistService`接口和实现，让它返回DTO，并能处理对特定播放列表的请求。

    ```java
    // In: src/main/java/com/vibevault/service/PlaylistService.java
    import com.vibevault.dto.PlaylistDTO;
    import com.vibevault.model.Song;

    public interface PlaylistService {
        PlaylistDTO getPlaylistById(String id); // 改为通过ID获取
        void addSong(String playlistId, Song song);
        void removeSong(String playlistId, int songIndex);
    }

    // In: src/main/java/com/vibevault/service/PlaylistServiceImpl.java
    import com.vibevault.dto.PlaylistDTO;
    import com.vibevault.dto.SongDTO;
    import com.vibevault.model.Playlist; // 需要引入Playlist
    import com.vibevault.model.Song; // 需要引入Song
    import com.vibevault.repository.PlaylistRepository;
    import org.springframework.stereotype.Service;
    import java.util.List;
    import java.util.stream.Collectors;
    
    @Service
    public class PlaylistServiceImpl implements PlaylistService {
        private final PlaylistRepository repository;

        public PlaylistServiceImpl(PlaylistRepository repository) {
            this.repository = repository;
        }
        
        @Override
        public PlaylistDTO getPlaylistById(String id) {
            Playlist playlist = repository.load(id);
            
            List<SongDTO> songDTOs = playlist.getSongs().stream()
                .map(song -> new SongDTO(song.title(), song.artist()))
                .collect(Collectors.toList());
            return new PlaylistDTO(playlist.getName(), songDTOs);
        }

        @Override
        public void addSong(String playlistId, Song song) {
            Playlist playlist = repository.load(playlistId);
            playlist.addSong(song);
            repository.save(playlist);
        }

        @Override
        public void removeSong(String playlistId, int songIndex) {
            Playlist playlist = repository.load(playlistId);
            // 注意，API层面接收的可能是1-based index，需要转换为0-based
            playlist.removeSong(songIndex - 1);
            repository.save(playlist);
        }
    }
    ```

3.  **修改Controller**: 让Controller处理带路径变量的URL，并返回`PlaylistDTO`。

    ```java
    // In: src/main/java/com/vibevault/controller/PlaylistController.java
    import com.vibevault.dto.PlaylistDTO;
    import com.vibevault.dto.SongDTO; // 需要引入
    import com.vibevault.model.Song;
    import com.vibevault.service.PlaylistService; // PlaylistService要引入
    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.*;
    
    @RestController
    @RequestMapping("/api/playlists")
    public class PlaylistController {
    
        private final PlaylistService playlistService;
    
        public PlaylistController(PlaylistService playlistService) {
            this.playlistService = playlistService;
        }
    
        @GetMapping("/{id}")
        public PlaylistDTO getPlaylist(@PathVariable String id) {
            return playlistService.getPlaylistById(id);
        }
    
        @PostMapping("/{id}/songs")
        @ResponseStatus(HttpStatus.CREATED)
        public void addSongToPlaylist(@PathVariable String id, @RequestBody SongDTO songDTO) {
            // 在真实应用中，这里应该有更复杂的DTO到领域模型的转换逻辑
            Song song = new Song(songDTO.title(), songDTO.artist(), songDTO.durationInSeconds());
            playlistService.addSong(id, song);
        }
    }
    ```

再次重启应用并访问`http://localhost:8080/api/playlists/my-favorites`。这次，你将看到一个结构清晰的JSON对象！这才是专业且符合RESTful风格的API。

### 第六步：处理“资源未找到”的情况 (最佳实践)

当我们尝试访问一个不存在的播放列表时，例如 `http://localhost:8080/api/playlists/non-existent-id`，目前的实现会返回一个空的播放列表，HTTP状态码是 `200 OK`。这在语义上是错误的。客户端应该明确地被告知“你请求的资源不存在”。

REST API的最佳实践是返回 `404 Not Found` 状态码。在Spring Boot中，我们可以通过自定义异常和全局异常处理器来优雅地实现这一点。

1.  **创建自定义异常**:
    ```java
    // In: src/main/java/com/vibevault/exception/ResourceNotFoundException.java
    package com.vibevault.exception;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(value = HttpStatus.NOT_FOUND)
    public class ResourceNotFoundException extends RuntimeException {
        public ResourceNotFoundException(String message) {
            super(message);
        }
    }
    ```
    *`@ResponseStatus`注解会自动让所有未被捕获的此类型异常，都返回404状态码。*

2.  **在Service层抛出异常**: 当加载的播放列表为空时，抛出我们的新异常。
    ```java
    // In: src/main/java/com/vibevault/service/PlaylistServiceImpl.java
    // ... imports ...
    import com.vibevault.exception.ResourceNotFoundException;

    @Service
    public class PlaylistServiceImpl implements PlaylistService {
        // ...
        @Override
        public PlaylistDTO getPlaylistById(String id) {
            Playlist playlist = repository.load(id);
            if (playlist.getSongs().isEmpty() && Files.notExists(Paths.get("data", id + ".csv"))) { // 更精确的判断
                 throw new ResourceNotFoundException("Playlist not found with id: " + id);
            }
            // ... a reste du code ...
        }
        // ...
    }
    ```

3.  **验证**: 重启应用，再次访问 `http://localhost:8080/api/playlists/non-existent-id`。这次，你将看到一个标准的404错误页面，这才是正确的、专业的API行为。

### 思考与练习

1.  **编码练习**: 基于以上知识，尝试实现`POST /api/playlists/songs`端点，用于向播放列表添加一首新歌。
    *   你需要在Controller方法上使用`@PostMapping("/songs")`。
    *   你需要使用`@RequestBody`注解来接收客户端发送过来的歌曲JSON数据，并将其绑定到一个`SongDTO`对象上。
    *   你需要修改`PlaylistService`来接收`SongDTO`并将其转换为`Song`领域对象。
    *   使用Postman或类似的API工具来测试你的新端点。

2.  **思考**: `@RestController`注解和传统的`@Controller`注解有什么区别？（提示：可以查阅一下`@ResponseBody`注解的作用，`@RestController`其实是`@Controller` + `@ResponseBody`的组合。） 