# VibeVault: 一场现代Java全栈之旅 - 完整课程目录

## 课程概述

**课程名称**: VibeVault: 一场现代Java全栈之旅  
**副标题**: 一份AI协同的、项目驱动的编程指南  
**作者**: 陆海波 上海应用技术大学 经济与管理学院

**技术栈**:
- 核心语言: Java 21 (LTS)
- 构建工具: Gradle (with Kotlin DSL)
- 后端框架: Spring Boot 3.x
- 数据库: PostgreSQL
- 前端框架: React (with Vite)
- 前端样式: Tailwind CSS
- 安全认证: JWT (JSON Web Token)
- 测试: JUnit 5, Mockito, AssertJ
- 部署: Docker

---

## 课程结构

### 第零章：欢迎来到Vibe Coding的世界 ✅ 已完成

**章节目标**: 校准世界观，揭示AI时代的编程新范式，分析机遇与陷阱，提供茁壮成长的黄金法则。

**包含小节**:
1. **0.1 - Vibe的转变：什么是Vibe Coding？** ✅
   - 核心思想: 介绍Vibe Coding的核心理念，从"码农"到"创造者"和"架构师"
   - 状态: 已完成

2. **0.2 - 70%难题：AI的机遇与陷阱** ✅
   - 核心思想: 深入探讨"70%难题"，理解AI的超能力与致命弱点
   - 状态: 已完成

3. **0.3 - 初学者如何在AI时代茁壮成长：黄金法则** ✅
   - 核心思想: 提出"拥抱第一性原理"和"绝不使用你不理解的代码"等黄金法则
   - 状态: 已完成

4. **0.4 - 附录：终极对决——为什么是Java？** ✅
   - 核心思想: 从第一性原理出发，系统性地论证为什么选择Java
   - 状态: 已完成

---

### 第一章：从"无"到"有"：创造你的第一个"数字原子" ✅ 已完成

**章节危机**: 如何将抽象的"音乐"想法赋予精确的数字形态？  
**章节顿悟**: `record Song` 是我们为"歌曲"创造的第一个"数字原子"

**包含小节**:
1. **1.1 - 思想的铸币厂：为何需要语言、IDE与构建工具？** ✅
   - 核心思想: 从第一性原理探讨编程语言、IDE和构建工具的本质
   - 状态: 已完成

2. **1.2 - 搭建工坊：配置你的现代化开发环境** ✅
   - 核心思想: 安装和配置JDK 21、VS Code、Gradle
   - 状态: 已完成

3. **1.3 - 绘制蓝图：初始化你的Gradle项目** ✅
   - 核心思想: 使用`gradle init`创建标准Java项目，理解目录结构
   - 状态: 已完成

4. **1.4 - 铸造第一个原子：定义Song Record** ✅
   - 核心思想: 使用Java 21的`record`关键字定义`Song`，完成从"定义"到"存在"的闭环
   - 状态: 已完成

---

### 第二章：从"一"到"多"：构建第一个"分子结构" ✅ 已完成

**章节危机**: 单个原子无法表达复杂意义，如何从"一"走向"多"？  
**章节顿悟**: `class Playlist`是我们创造的第一个"分子结构"

**包含小节**:
1. **2.0 - Git版本控制** ✅
   - 核心思想: 学习Git基础，管理代码版本
   - 状态: 已完成

2. **2.1 - 为何要封装？从数据集合到业务对象** ✅
   - 核心思想: 从第一性原理探讨封装的本质：隐藏实现细节、明确业务责任
   - 状态: 已完成

3. **2.2 - 设计播放列表"分子"** ✅
   - 核心思想: 学习Java `class`语法，定义`Playlist`类
   - 状态: 已完成

4. **2.3 - 选择容器：为何是ArrayList？** ✅
   - 核心思想: 剖析`ArrayList`, `LinkedList`, `HashSet`的性能权衡
   - 状态: 已完成

---

### 第三章：从"静"到"动"：赋予创造物与世界对话的能力 ✅ 已完成

**章节危机**: 我们的`Playlist`是"死"的，无法在运行时互动  
**章节顿悟**: 建立"对话通道"，让用户通过输入来感知和改变创造物

**包含小节**:
1. **3.1 - 为何需要交互？批处理 vs. 事件循环** ✅
   - 核心思想: 探讨批处理与交互式程序的根本区别，揭示事件循环的本质
   - 状态: 已完成

2. **3.2 - 建立对话通道：主循环与用户输入** ✅
   - 核心思想: 编写`while(true)`无限循环，使用`Scanner`读取用户输入
   - 状态: 已完成

3. **3.3 - 定义沟通协议：Switch与方法调用** ✅
   - 核心思想: 使用`switch`语句构建指令分发中心，连接UI和业务逻辑
   - 状态: 已完成

---

### 第四章：对抗"遗忘"：让记忆穿越关机的黑暗 ✅ 已完成

**章节危机**: 程序关闭后，一切灰飞烟灭，遭遇"遗忘"危机  
**章节顿悟**: 将内存中的对象"序列化"为可记录格式，刻写在磁盘上

**包含小节**:
1. **4.1 - 为何需要持久化？RAM vs. Disk** ✅
   - 核心思想: 从第一性原理理解RAM和Disk在速度、成本、易失性上的差异
   - 状态: 已完成

2. **4.2 - 序列化：将对象翻译成文字** ✅
   - 核心思想: 实现`toCsvString()`和`fromCsvString()`，完成对象与文字的互换
   - 状态: 已完成

3. **4.3 - 代码的韧性：文件IO与异常处理** ✅
   - 核心思想: 学习Java NIO.2的`Files`类，使用`try-catch`处理`IOException`
   - 状态: 已完成

**⚠️ 注意**: 根据大纲，本章应包含4个小节，但目前只有3个。大纲中提到的`03-inscription.qmd`（刻写石碑：现代文件I/O）的内容似乎已整合到其他小节中。

---

### 第五章：对抗"脆弱"：我们如何相信自己写下的代码？ ✅ 已完成

**章节危机**: 数据可以永久保存，但代码变得脆弱，不敢轻易修改  
**章节顿悟**: 信任来自可重复的、自动化的"证明"，单元测试是"安全网"

**包含小节**:
1. **5.1 - 信任危机与安全网** ✅
   - 核心思想: 剖析手动测试的缺陷，揭示自动化测试的本质
   - 状态: 已完成

2. **5.2 - 搭建测试实验室：JUnit 5初体验** ✅
   - 核心思想: 搭建测试环境，编写第一个测试，熟悉工具链
   - 状态: 已完成

3. **5.3 - 精确的断言：AssertJ的流畅表达** ✅
   - 核心思想: 引入AssertJ，学习流畅的断言API，编写有意义的单元测试
   - 状态: 已完成

4. **5.4 - 伪造现实：Mockito的when-thenReturn** ✅
   - 核心思想: 学习Mockito的打桩(Stubbing)，创建测试替身
   - 状态: 已完成

5. **5.5 - 验证行为：Mockito的verify** ✅
   - 核心思想: 学习Mockito的行为验证(Verification)，测试副作用
   - 状态: 已完成

**⚠️ 注意**: 根据大纲，本章应包含一个小节"隔离的原则：为何测试讨厌'真实世界'"，但实际章节中似乎没有独立的文件。相关内容可能已整合到其他小节中。

---

### 第六章：对抗"混沌"：当代码变成一团乱麻 ✅ 已完成

**章节危机**: 代码挤在几个文件里，修改一处影响全局，熵增导致混沌  
**章节顿悟**: 对抗软件混沌的唯一武器是"秩序"，引入"关注点分离"架构

**包含小节**:
1. **6.1 - 为何需要架构？对抗软件的熵增** ✅
   - 核心思想: 探讨软件熵增定律，论证架构的本质是对抗熵增的约束
   - 状态: 已完成

2. **6.2 - 关注点分离：三层架构** ✅
   - 核心思想: 学习分层架构，划分为表现层、业务逻辑层、数据访问层
   - 状态: 已完成

3. **6.3 - 重构！建立新秩序** ✅
   - 核心思想: 进行大规模代码重构，创建新包和新类，将逻辑迁移到正确位置
   - 状态: 已完成

---

### 第七章：对抗"孤立"：打开通往世界的大门 ✅ 已完成

**章节危机**: 应用是"孤岛"，只存在于命令行世界  
**章节顿悟**: 通过"网络"建立标准化的"对话协议"，Web API打破进程壁垒

**包含小节**:
1. **7.1 - 为何需要API？应用程序的"外交协议"** ✅
   - 核心思想: 从第一性原理探讨API的本质，理解REST API风格
   - 状态: 已完成

2. **7.2 - 为何选择Spring Boot？站在巨人的肩膀上** ✅
   - 核心思想: 理解Spring Boot的"约定优于配置"和"自动配置"
   - 状态: 已完成

3. **7.3 - 构建你的第一个API端点** ✅
   - 核心思想: 学习`@RestController`, `@Service`, `@Repository`注解，创建第一个API
   - 状态: 已完成

---

### 第八章：对抗"无序"：驯服并发访问的猛兽 ✅ 已完成

**章节危机**: 并发访问导致数据损坏，文件系统在并发面前不堪一击  
**章节顿悟**: 需要专业的、为并发设计的系统——关系型数据库

**包含小节**:
1. **8.1 - 为何需要数据库？ACID的四大守护** ✅
   - 核心思想: 剖析文件存储的缺陷，揭示关系型数据库的ACID特性
   - 状态: 已完成

2. **8.2 - 为何需要ORM？跨越对象与关系的鸿沟** ✅
   - 核心思想: 理解ORM的本质，作为对象与关系的"翻译层"
   - 状态: 已完成

3. **8.3 - 迁移到PostgreSQL** ✅
   - 核心思想: 使用Spring Data JPA与PostgreSQL对话，学习JPA注解
   - 状态: 已完成

---

### 第九章：对抗"隐形"：为你的API穿上华丽的外衣 ✅ 已完成

**章节危机**: API功能强大但对用户"隐形"，没有可见界面  
**章节顿悟**: 需要"客户端"消费API，构建现代化的用户界面

**包含小节**:
1. **9.1 - 为何需要前后端分离？** ✅
   - 核心思想: 从第一性原理探讨前后端分离的本质和优势
   - 状态: 已完成

2. **9.2 - 为何选择React？声明式的UI革命** ✅
   - 核心思想: 理解React的声明式UI和虚拟DOM抽象层
   - 状态: 已完成

3. **9.3 - React前的必修课：现代JavaScript语法速成** ✅
   - 核心思想: 为Java开发者准备的JavaScript核心概念快速通道
   - 状态: 已完成

4. **9.4 - React的核心魔法：到底什么是Hook？** ✅
   - 核心思想: 理解React Hooks的本质，如何"钩入"状态和生命周期
   - 状态: 已完成

5. **9.5 - 实战：构建你的第一个React组件** ✅
   - 核心思想: 使用Vite搭建React项目，通过`fetch` API连接前后端
   - 状态: 已完成

---

### 第十章：对抗"匿名"：认证，回答"你是谁" ❌ 缺失

**章节危机**: VibeVault完全开放和匿名，任何人都可以访问所有API  
**章节顿悟**: 需要引入"身份"概念，可靠地回答"你是谁"——认证(Authentication)

**包含小节** (计划):
1. **10.1 - 为何需要认证？**
   - 核心思想: 从第一性原理探讨认证与授权的本质区别
   - 状态: ❌ 缺失

2. **10.2 - 第一道防线：默认安全**
   - 核心思想: 引入Spring Security，体验"默认安全"原则
   - 状态: ❌ 缺失

3. **10.3 - 数字身份的基石：用户与密码**
   - 核心思想: 创建`User`实体，学习BCrypt密码加密
   - 状态: ❌ 缺失

4. **10.4 - 敞开大门：构建认证API**
   - 核心思想: 创建注册和登录API，编写第一个集成测试
   - 状态: ❌ 缺失

**章末危机**: 用户可以注册和登录，但登录后服务器会"忘记"身份，创造下一章的"失忆危机"

---

### 第十一章：对抗"遗忘"：JWT，无状态的数字护照 ❌ 缺失

**章节危机**: HTTP协议是"健忘"的，登录后服务器不认识用户了  
**章节顿悟**: 需要"自包含的数字护照"，让用户携带身份证明——JWT

**包含小节** (计划):
1. **11.1 - 为何选择JWT？无状态的数字护照**
   - 核心思想: 对比Session和JWT，理解JWT的三段式结构
   - 状态: ❌ 缺失

2. **11.2 - 数字护照办公室：签发JWT**
   - 核心思想: 创建`JwtService`，实现Token生成
   - 状态: ❌ 缺失

3. **11.3 - 城门的哨兵：验证JWT**
   - 核心思想: 创建`JwtAuthenticationFilter`，验证JWT签名
   - 状态: ❌ 缺失

4. **11.4 - 外交豁免：处理CORS**
   - 核心思想: 理解同源策略，在`SecurityConfig`中配置CORS
   - 状态: ❌ 缺失

**章末危机**: 系统能识别"你是谁"，但用户A可以操作用户B的数据，创造最终章的"所有权危机"

---

### 第十二章：对抗"越界"：授权，划定你的边界 ❌ 缺失

**章节危机**: 系统没有"边界感"，任何登录用户都可以操作不属于他的资源  
**章节顿悟**: 建立"所有权"概念，实施访问控制，回答"你能做什么"——授权

**包含小节** (计划):
1. **12.1 - 地基危机：业务主键的陷阱**
   - 核心思想: 发现`Playlist`使用`String name`作为主键的缺陷，引入技术主键
   - 状态: ❌ 缺失

2. **12.2 - 重构！为身份加固地基**
   - 核心思想: 将`Playlist`主键从`String`改为自增的`Long id`
   - 状态: ❌ 缺失

3. **12.3 - 建立所有权关联**
   - 核心思想: 建立`User`和`Playlist`的`@ManyToOne`/`@OneToMany`关联
   - 状态: ❌ 缺失

4. **12.4 - 声明式授权：@PreAuthorize**
   - 核心思想: 引入Spring Security的`@PreAuthorize`，实现声明式安全
   - 状态: ❌ 缺失

5. **12.5 - 总结：你的工程师蓝图**
   - 核心思想: 回顾"安全三部曲"旅程，展望更高级安全主题
   - 状态: ❌ 缺失

---

### 第十三章：对抗"环境"：容器化，代码的"生命胶囊" ❌ 缺失

**章节危机**: "在我的电脑上可以运行"的诅咒，环境差异导致麻烦  
**章节顿悟**: 交付包含完整运行环境的"生命胶囊"——容器

**包含小节** (计划):
1. **13.1 - 为何需要容器化？**
   - 核心思想: 对比虚拟机和容器，理解容器化的本质
   - 状态: ❌ 缺失

2. **13.2 - 编写应用的"DNA序列"**
   - 核心思想: 学习编写`Dockerfile`，构建Docker镜像
   - 状态: ❌ 缺失

3. **13.3 - 指挥一场"容器交响乐"**
   - 核心思想: 编写`docker-compose.yml`，编排应用和数据库
   - 状态: ❌ 缺失

---

### 第十四章：对抗"停滞"：消费外部API，汲取生态养分 ❌ 缺失

**章节危机**: 系统是内向的、停滞的，无法利用外部世界的能力  
**章节顿悟**: 学会"消费"外部API，从外部世界汲取养分

**包含小节** (计划):
1. **14.1 - 为何需要消费外部API？**
   - 核心思想: 探讨现代软件开发的本质——构建在现有服务之上
   - 状态: ❌ 缺失

2. **14.2 - 实现AI DJ：与"超级大脑"对话**
   - 核心思想: 学习调用外部AI服务API（如OpenAI），实现AI DJ功能
   - 状态: ❌ 缺失

---

### 第十五章：最终的诞生：部署到世界舞台 ❌ 缺失

**章节目标**: 将应用发布到云端，赋予它真正的生命

**包含小节** (计划):
1. **15.1 - 为何需要云？**
   - 核心思想: 探讨云计算的优势：弹性、可靠性、成本效益
   - 状态: ❌ 缺失

2. **15.2 - 部署到云端**
   - 核心思想: 完成部署步骤，将Docker镜像部署到云服务器
   - 状态: ❌ 缺失

3. **15.3 - 旅程的终点，亦是起点**
   - 核心思想: 回顾完整旅程，总结核心工程思想，展望未来
   - 状态: ❌ 缺失

---

## 附录 ✅ 已完成

- **附录：第一性原理** ✅
  - 状态: 已完成

---

## 课程完成度统计

### 已完成章节 (10/16)
- ✅ 第零章：欢迎 (4/4小节)
- ✅ 第一章：创世纪 (4/4小节)
- ✅ 第二章：聚合 (4/4小节)
- ✅ 第三章：交互 (3/3小节)
- ✅ 第四章：持久化 (3/3小节)
- ✅ 第五章：信任 (5/5小节)
- ✅ 第六章：秩序 (3/3小节)
- ✅ 第七章：连接 (3/3小节)
- ✅ 第八章：并发 (3/3小节)
- ✅ 第九章：可见性 (5/5小节)

### 缺失章节 (6/16)
- ❌ 第十章：身份认证 (0/4小节) - 完全缺失
- ❌ 第十一章：JWT (0/4小节) - 完全缺失
- ❌ 第十二章：授权 (0/5小节) - 完全缺失
- ❌ 第十三章：容器化 (0/3小节) - 完全缺失
- ❌ 第十四章：消费外部API (0/2小节) - 完全缺失
- ❌ 第十五章：部署 (0/3小节) - 完全缺失

### 总体进度
- **已完成**: 10章 (62.5%)
- **缺失**: 6章 (37.5%)
- **总小节数**: 已完成 37小节，计划 21小节缺失

---

## 建议补全计划

### 优先级1: 安全三部曲 (第十、十一、十二章)
这三章构成了完整的安全体系，是Web应用的核心功能：
1. **第十章：认证** - 建立用户身份系统
2. **第十一章：JWT** - 实现无状态认证
3. **第十二章：授权** - 实现访问控制

### 优先级2: 部署相关 (第十三、十五章)
这两章让应用能够真正部署到生产环境：
1. **第十三章：容器化** - Docker基础
2. **第十五章：部署** - 云端部署

### 优先级3: 功能扩展 (第十四章)
增强应用功能：
1. **第十四章：消费外部API** - AI集成等功能扩展

---

## 技术栈覆盖情况

### 已覆盖
- ✅ Java 21基础语法和特性
- ✅ Gradle构建工具
- ✅ 面向对象编程 (封装、集合)
- ✅ 文件I/O和序列化
- ✅ JUnit 5 和 Mockito测试
- ✅ 三层架构设计
- ✅ Spring Boot基础
- ✅ REST API设计
- ✅ Spring Data JPA和PostgreSQL
- ✅ React基础 (组件、Hooks)
- ✅ 前后端分离架构

### 待覆盖
- ❌ Spring Security
- ❌ JWT认证
- ❌ 授权和访问控制
- ❌ Docker容器化
- ❌ Docker Compose
- ❌ 外部API调用 (HTTP客户端)
- ❌ 云平台部署
- ❌ CI/CD概念

---

## 备注

1. **大纲文件命名**: 注意outline目录中的文件名可能与实际章节编号不一致：
   - `11-portability.md` 实际内容是JWT相关
   - `12-evolution.md` 实际内容是授权相关
   - `13-birth.md` 实际内容是容器化
   - `14-evolution.md` 实际内容是消费外部API
   - `15-birth.md` 实际内容是部署

2. **章节编号**: 实际章节编号从0开始（第零章），但大纲文件使用了不同的命名方式。

3. **内容完整性**: 已完成章节的内容基本完整，但建议审查：
   - 第四章是否缺少"刻写石碑"小节（大纲中有但实际文件中可能已整合）
   - 第五章是否缺少"隔离的原则"小节（大纲中有但实际文件中可能已整合）

---

**生成时间**: 2025年1月  
**最后更新**: 基于项目当前状态审查

