好的，这是您提供的书籍《Vibe Coding: The Future of Programming》内容的中文翻译，已整理为 Markdown 格式。

---

# Vibe Coding：编程的未来
## 在人工智能辅助编码时代利用您的经验
**作者：Addy Osmani**

> **关于早期发布**
> 通过早期发布（Early Release）的电子书，您可以在作者写作的最初阶段就获取到书籍的原始、未经编辑的内容，从而在这些技术正式发布之前就能加以利用。

---

## 简要目录 (尚未最终确定)

*   **第 1 章：** Vibe 的转变：意图编程 (暂不可用)
*   **第 2 章：** 提示的艺术：与人工智能有效沟通 (暂不可用)
*   **第 3 章：** 70% 难题：关于人工智能辅助编码的残酷真相 (可用)
*   **第 4 章：** 超越 70%：最大化人类贡献 (可用)
*   **第 5 章：** 理解生成的代码：审查、优化、拥有 (暂不可用)
*   **第 6 章：** 人工智能驱动的原型设计：工具与技术 (暂不可用)
*   **第 7 章：** 用人工智能构建 Web 应用 (暂不可用)
*   **第 8 章：** 人工智能生成代码的安全性与可靠性 (暂不可用)
*   **第 9 章：** Vibe Coding 的伦理影响 (暂不可用)
*   **第 10 章：** 程序员的解构：个人软件 (暂不可用)
*   **第 11 章：** 超越代码生成：人工智能不断扩展的角色 (暂不可用)
*   **第 12 章：** Vibe Coder 的工具包：高级技术 (暂不可用)

---

# 第 1 章. 70% 难题：真正有效的人工智能辅助工作流

> **致早期发布读者的说明**
> 这将是最终书籍的第 3 章。如果您对如何改进本书的内容和/或示例有任何意见，或者您在阅读本章时发现任何缺失的材料，请联系编辑。

基于人工智能的编码工具在某些任务上表现得惊人地出色。它们擅长生成样板代码、编写常规函数，以及将项目推进到接近完成的阶段。事实上，许多开发人员发现，人工智能助手可以实现一个初步的解决方案，覆盖大约 70% 的需求。

Peter Yang 的一条推文完美地捕捉到了我在该领域观察到的现象：

> 作为一名非工程师，到目前为止，关于使用人工智能编码的真实感想：
> 它可以帮你完成 70% 的工作，但最后那 30% 却令人沮丧。它不断地在修复一个问题时引入新的 bug、问题等等，让你进一步退两步。
> 如果我懂代码是如何工作的，我或许可以自己修复它。但正因为我不懂，我怀疑自己是否真的学到了很多东西。

使用人工智能进行编码的非工程师们发现自己撞上了一堵令人沮ر的墙。他们可以出奇地快速完成 70% 的路程，但最后那 30% 却成了一场收益递减的练习。

这个“70% 难题”揭示了当前人工智能辅助开发状态的一些关键问题。最初的进展感觉就像魔法——你可以描述你想要什么，然后像 v0 或 Bolt 这样的人工智能工具就会生成一个看起来令人印象深刻的工作原型。但随后现实就来临了。

这 70% 通常是工作中直接、模式化的部分——那种遵循成熟路径或通用框架的代码。正如一位 Hacker News 评论者所观察到的，人工智能在处理软件的“偶然复杂性”（重复性、机械性的工作）方面表现出色，而“本质复杂性”——理解和管理问题内在的复杂性——仍然落在人类的肩上。

这些工具在哪里会遇到困难？经验丰富的工程师一致报告存在一个“最后一英里”的差距。人工智能可以生成一个看似合理的解决方案，但最后的 30%——覆盖边缘情况、优化架构和确保可维护性——“需要严肃的人类专业知识”。

此外，人工智能有一个众所周知的倾向，即生成令人信服但错误的输出。它可能会引入细微的 bug 或“幻觉出”不存在的函数和库。Steve Yegge 尖锐地将当今的 LLM（大型语言模型）比作“效率极高的初级开发人员”——速度快得令人难以置信，充满热情，但“可能像磕了改变心智的药物一样精神错乱”，容易炮制出疯狂或不可行的方法。

至关重要的是，当前的人工智能不会在其训练数据之外创造出全新的抽象或策略。它们不会为你发明一种新颖的算法或创新的架构——它们只是重新组合已知的东西。它们也不会为决策承担责任。

所有这一切都意味着创造性和分析性思维——决定构建什么、如何构建以及为何构建——仍然牢牢地属于人类领域。

我观察到团队在利用人工智能进行开发时有两种截然不同的模式。让我们称之为“引导者 (bootstrappers)”和“迭代者 (iterators)”。

1.  **引导者**：他们通常是从零开始构建一个新项目到 MVP。像 Bolt、v0 和截图转代码（screenshot-to-code）这样的人工智能工具正在彻底改变这些团队启动新项目的方式。
2.  **迭代者**：他们在日常开发工作流中使用像 Cursor、Cline、Copilot 和 WindSurf 这样的工具。这种方式不那么引人注目，但可能更具变革性。

但这里有一个陷阱：虽然这两种方法都可以极大地加速开发，但它们也带来了不那么明显的隐藏成本。当你看到一位高级工程师使用人工智能工具工作时，他们不仅仅是接受人工智能的建议。他们不断地将生成的代码重构成更小、更专注的模块。他们在添加人工智能遗漏的全面错误处理和边缘情况处理。换句话说，他们正在运用多年来之不易的工程智慧来塑造和约束人工智能的输出。

### 常见的失败模式

初级工程师常常会忽略这些关键步骤。他们更容易接受人工智能的输出，导致我称之为“纸牌屋代码”——看起来很完整，但在现实世界的压力下就会崩溃。

**退两步 (Two Steps Back)**

接下来通常会发生的事情遵循一个可预测的模式，我称之为“退两步”模式：
1.  你试图修复一个小错误。
2.  人工智能建议一个看起来合理的更改。
3.  这个修复破坏了其他东西。
4.  你要求人工智能修复新问题。
5.  这又创造了两个更多的问题。
6.  周而复始。

这个循环对于非工程师来说尤其痛苦，因为他们缺乏理解问题真正所在的思维模型。这就是我在本书前言中提到的“知识悖论”：高级工程师和开发者使用人工智能来加速他们已经知道如何做的事情，而初级开发者则试图用它来学习该怎么做。

随着更自主的“代理式”人工智能系统的兴起，这种依赖风险可能会加深。如果没有对底层流程的扎实理解，用户可能会发现自己越来越依赖这些代理，当事情出错时无法有效干预。

### 演示质量陷阱 (The Demo-Quality Trap)

这正在成为一种模式：团队使用人工智能快速构建令人印象深刻的演示。顺利的路径完美运行。但当真实用户开始四处点击时，那就是事情开始分崩离析的时候。

我亲身经历过这种情况：对普通用户来说毫无意义的错误信息、导致应用程序崩溃的边缘情况、被完全忽略的可访问性、在较慢设备上的性能问题。这些不仅仅是低优先级的错误——它们是人们容忍的软件和人们喜爱的软件之间的区别。

创建真正能让用户自助服务的软件需要一种不同的心态，一种专注于被遗忘的“打磨”艺术的心态。这种对细节的关注（或许）是无法由人工智能生成的。它来自于同理心、经验和对工艺的深切关怀。

### 真正有效的方法：实用的工作流模式

在观察了数十个团队之后，我发现有三种模式在个人和团队工作流程中都持续有效：

*   **AI 作为初稿起草者 (AI as first drafter)**，即 AI 模型生成初始代码，然后由开发人员进行优化、重构和测试。
*   **AI 作为结对程序员 (AI as pair programmer)**，即开发人员和 AI 处于持续对话中，具有紧密的反馈循环和频繁的代码审查。
*   **AI 作为验证者 (AI as validator)**，即开发人员仍然编写初始代码，然后使用 AI 来验证、测试和改进它。

### AI 作为初稿起草者 (AI as First Drafter)

在让你的 AI 模型开始起草任何代码之前，确保团队中的每个人都在同一页面上非常重要。沟通是关键。成功整合人工智能工具的团队通常从就编码标准和提示实践达成一致开始。正如 Codacy 的博客指出的，通过让 AI 熟悉团队的编码标准，你可以获得更统一、更容易让每个人使用的生成代码。

### AI 作为结对程序员 (AI as Pair Programmer)

传统的结对编程涉及两个人类在一个工作站上协作。随着 AI 的出现，一种混合方法已经出现：一个人类开发者与一个 AI 助手并肩工作。这种设置可能特别有效，提供了人类直觉和机器效率的结合。

**AI 结对编程的最佳实践**
*   **为不同的任务启动新的 AI 会话**：这有助于保持上下文清晰，并确保 AI 的建议与手头的具体任务相关。
*   **保持提示的专注和简洁**：提供清晰具体的指令可以提高 AI 输出的质量。
*   **频繁审查并提交变更**：定期集成和测试 AI 生成的代码有助于及早发现问题并保持项目势头。
*   **保持紧密的反馈循环**：持续评估 AI 的贡献，根据需要提供纠正或改进，以指导其学习并改善未来的建议。

### AI 作为验证者 (AI as Validator)

除了代码生成，AI 还可以作为有价值的验证者，在代码审查和质量保证方面提供帮助。AI 工具可以分析代码中的潜在错误、安全漏洞以及是否遵循最佳实践。通过将 AI 验证器集成到开发工作流程中，团队可以提高代码质量，减少缺陷的可能性，并确保符合安全标准。

### Vibe Coding 的黄金法则

*   **具体而清晰地说明你想要什么**：清晰地阐明你的要求、任务和预期结果。精确的提示会产生精确的结果。
*   **始终根据你的意图验证 AI 的输出**：在接受之前，验证其功能、逻辑和相关性。
*   **将 AI 视为一个需要监督的初级开发者**：将 AI 的输出视为需要你仔细监督的草稿。
*   **利用 AI 扩展你的能力，而不是取代你的思考**：利用 AI 自动化常规任务，但始终积极参与解决问题和决策过程。
*   **在生成代码前与团队进行前期协调**：与你的团队就 AI 使用标准、代码期望和实践达成一致。
*   **将 AI 的使用视为开发对话的正常部分**：定期与你的团队讨论 AI 的经验、技术、成功案例和陷阱。
*   **在 Git 中通过单独的提交来隔离 AI 的更改**：清晰地识别和分离 AI 生成的更改，以简化审查、回滚和跟踪。
*   **确保所有代码，无论是人写的还是 AI 写的，都经过代码审查**：维持一致的标准，提高代码质量和团队理解。
*   **不要合并你不理解的代码**：理解对于可维护性和安全性至关重要。
*   **优先考虑文档、注释和 ADR**：良好的文档可以确保长期的清晰度并减少未来的技术债务。
*   **分享和重用有效的提示**：维护一个经过验证的提示库，以简化未来的互动并增强一致性。
*   **定期反思和迭代**：利用过去的经验洞察来持续提升团队的方法。

---

# 第二章. 超越 70%：最大化人类的贡献

> **致早期发布读者的说明**
> 这将是最终书籍的第 4 章。如果您对如何改进本书的内容和/或示例有任何意见，或者您在阅读本章时发现任何缺失的材料，请联系编辑。

你已经看到像 Cursor、Copilot 这样的人工智能编码助手如何改变了软件的构建方式，承担了大约 70% 的繁重工作。但那剩下的、将一个玩具解决方案与一个生产就绪系统区分开来的“30%”工作呢？这个差距包括了困难的部分：理解复杂的需求、构建可维护的系统、处理边缘情况以及确保代码的正确性。换句话说，虽然人工智能可以生成*代码*，但它常常在*工程*上遇到困难。

Tim O'Reilly 在反思几十年的技术变革时提醒我们，每一次自动化飞跃都改变了*我们如何编程*，但并没有改变*我们为什么需要熟练的程序员*。我们面临的不是编程的终结，而是“我们今天所知的编程的终结”。

### 高级工程师和开发人员：利用你的经验与 AI 协作

如果你是一名高级工程师，你应该将 AI 编码工具的出现视为一个放大你影响力的机会。

*   **成为架构师和总编辑**：让 AI 处理代码的初稿，而你则专注于构建解决方案的架构，然后优化 AI 的输出。你实际上是在与 AI 进行结对编程——它是打字快手，但你是大脑。
*   **将 AI 作为重大项目的力量倍增器**：利用 AI 处理大型项目或棘手的重构。关键在于保持主导思想：你决定追求哪些工具或方法，并将各个部分整合成一个有凝聚力的整体。
*   **指导和设定标准**：高级工程师的另一个关键角色是指导经验不足的团队成员有效使用 AI，并传授永不过时的最佳实践。
*   **继续培养领域专长和远见**：你广泛的经验和背景比以往任何时候都更加重要。这种领域专长能让你发现新手不会注意到的 AI 失误。
*   **磨练你的软技能和领导力**：随着 AI 承担了部分编码工作，高级开发人员可以将更多精力投入到工程的人文方面，如与利益相关者沟通、主持设计会议等。

### 中级工程师：适应与专精

如果你是一名中级工程师，你可能面临着最大的发展压力。重点从编写代码转向更专业的知识。

*   **学会管理系统集成和边界**：随着系统变得越来越复杂，理解和管理组件之间的边界变得至关重要。
*   **建立你的领域专长**：专精于人类理解仍然至关重要的复杂领域，如金融、医疗等。
*   **掌握性能优化和 DevOps**：随着代码生成变得越来越自动化，了解系统在生产环境中的运行方式变得更有价值。
*   **专注于代码审查和质量保证**：随着 AI 编写大量代码，严格审查和测试这些代码的能力变得更加关键。
*   **学习系统思维**：理解系统中一个部分的改变可能会如何影响另一个部分，以及软件如何服务于业务目标。
*   **保持适应性——永不停止学习**：成为一个不断学习的工程师——这是任何时代都经得起考验的职业技能。
*   **擅长跨职能沟通**：在业务需求和技术解决方案之间进行转换的能力变得更有价值。
*   **学习系统设计与架构**：练习设计解决现实世界大规模问题的系统。
*   **涉足 UI 和 UX 设计**：成功的软件创造一直以来都不仅仅需要编码能力。工程判断和设计思维变得更加关键。

### 初级开发者：在 AI 时代茁壮成长

如果你是一名初级开发者，你需要积极主动地培养技能，以确保你贡献的价值超越 AI 所能大量产出的。

*   **学习基础知识：不要跳过“为什么”**：将 AI 用作导师，而不仅仅是一个答案贩卖机。问它*为什么*选择某种方法。
*   **在没有 AI 安全网的情况下练习解决问题和调试**：要建立真正的自信，有时你必须单飞。
*   **专注于测试和验证**：你能养成的最好习惯之一就是为你的代码编写测试。这能捕捉到 AI 输出中的问题，并训练你思考预期行为。
*   **培养对可维护性的眼光**：更难的部分是让代码可读、可维护和整洁。
*   **明智地发展你的提示和工具技能**：与 AI 工具有效互动的技能是有用的，但提示得好通常是理解问题得好的一个代表。
*   **寻求反馈和指导**：你的人类队友和导师对于你的发展是无价的。
*   **沟通与协作**：构建软件是一项团队运动。强大的沟通技巧一如既往地宝贵。
*   **转变你的思维方式：从消费到创造**：你需要从仅仅*消费*解决方案转向*创造*理解。

### 用持久的工程技能来保障你的职业生涯

总之，要在人工智能增强的开发世界中茁壮成长，工程师们都应该加倍投入到人工智能（尚）无法复制的持久技能和实践上。

*   加强你的系统设计和架构专业知识
*   练习系统思维并保持对大局的背景理解
*   磨练你的批判性思维、解决问题和远见的能力
*   在专业领域建立专业知识
*   审查代码、测试、调试和质量保证
*   提高你的沟通和协作能力
*   适应变化
*   持续学习，保持基础知识扎实
*   使用人工智能

这些技能构成了软件工程中的人类优势。它们之所以持久，是因为它们不会随着下一个框架或工具的更迭而过期。最终，伟大的软件工程一直都是关于解决问题，而不仅仅是敲代码。人工智能并没有改变这一点：它只是挑战我们提升我们的解决问题的能力到下一个层次。

---

## 关于作者

Addy Osmani 是 Google Chrome 的一名高级工程领导，他致力于开发者体验、性能和 AI 驱动的软件开发工具。他拥有超过 20 年的行业经验，构建网络技术，并撰写了多本关于软件工程最佳实践的书籍。他关于 AI 辅助软件开发的文章影响了成千上万的开发者。本书凝聚了他在软件工程方面的深厚专业知识和他对 AI 驱动编码助手的实践经验，为开发者提供了将 AI 融入日常工作流程并适应软件开发快速变化格局的实用策略。