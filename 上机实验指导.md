# VibeVault: 上机实验指导（24次）

**课程名称**: VibeVault: 一场现代Java全栈之旅  
**适用学期**: 2025-2026学年  
**实验总次数**: 24次  
**每次实验时长**: 2-3小时

---

## 实验说明

### 实验目标
通过24次递进式上机实验，完成从零到云端的完整全栈项目开发，掌握现代Java全栈开发的核心技能。

### 实验要求
1. **独立完成**: 每个实验必须独立完成，鼓励使用AI辅助，但必须理解每一行代码
2. **提交方式**: 每次实验完成后提交代码到Git仓库，并编写实验报告
3. **实验报告**: 包含实验目的、实验步骤、遇到的问题及解决方案、实验心得
4. **代码规范**: 遵循Java编码规范，保持代码整洁和可读性

### 评分标准
- 代码正确性（40%）
- 代码质量（20%）
- 实验报告（20%）
- 创新性思考（20%）

---

## 第一部分：基础入门（实验1-5）

### 实验1：开发环境搭建与项目初始化

**实验目的**:
- 掌握Java开发环境的搭建
- 熟悉VS Code和AI编程助手的配置
- 创建第一个Gradle项目

**实验内容**:
1. 安装JDK 21，验证安装成功
2. 安装VS Code及Java扩展包
3. 配置AI编程助手（Cursor/Copilot）
4. 使用`gradle init`创建Java应用项目
5. 理解项目目录结构

**实验步骤**:
1. 下载并安装JDK 21，配置`JAVA_HOME`和`PATH`环境变量
2. 在命令行验证：`java --version`、`javac --version`
3. 安装VS Code，安装Java Extension Pack
4. 配置AI编程助手（推荐使用Cursor或GitHub Copilot）
5. 在项目目录执行：`gradle init --type java-application`
6. 打开VS Code，查看项目结构，理解各目录作用

**实验检查点**:
- [ ] JDK 21安装成功，版本号正确
- [ ] VS Code能识别Java文件并显示语法高亮
- [ ] Gradle项目创建成功，能运行默认的`main`方法
- [ ] 能使用AI助手生成简单的Java代码注释

**实验报告要求**:
- 记录安装过程中遇到的问题及解决方案
- 截图展示开发环境配置成功的界面
- 思考：为什么需要配置`JAVA_HOME`环境变量？

---

### 实验2：定义第一个数据模型 - Song Record

**实验目的**:
- 理解Java `record`关键字的用法
- 掌握不可变数据结构的定义
- 学习Java程序的基本结构

**实验内容**:
1. 创建`Song` record，包含title、artist、durationInSeconds
2. 在`Main`类中创建多个`Song`实例
3. 打印`Song`对象信息
4. 探索`record`自动生成的方法

**实验步骤**:
1. 在`src/main/java/com/vibevault`目录下创建`Song.java`
2. 定义`Song` record：
   ```java
   public record Song(String title, String artist, int durationInSeconds) {
   }
   ```
3. 在`Main.java`中创建3个不同的`Song`实例
4. 使用`System.out.println`打印每个`Song`对象
5. 测试`equals()`和`hashCode()`方法

**实验检查点**:
- [ ] `Song` record定义正确，包含三个字段
- [ ] 能创建`Song`实例并打印其信息
- [ ] 理解`record`自动生成的`toString()`方法
- [ ] 测试两个相同内容的`Song`对象，`equals()`返回true

**扩展练习**:
- 为`Song`添加`albumTitle`字段
- 尝试修改`Song`实例的字段（应该失败，说明不可变性）

---

### 实验3：封装与类设计 - Playlist类

**实验目的**:
- 理解面向对象的封装思想
- 掌握Java类的定义和使用
- 学习构造函数和成员方法

**实验内容**:
1. 创建`Playlist`类，包含私有成员变量
2. 实现构造函数和getter方法
3. 实现`addSong`和`listSongs`方法
4. 理解封装的优势

**实验步骤**:
1. 创建`Playlist.java`文件
2. 定义私有成员变量：
   - `private String name`
   - `private List<Song> songs`
3. 编写构造函数初始化成员变量
4. 实现`getName()`和`getSongCount()`方法
5. 实现`addSong(Song song)`方法
6. 实现`listSongs()`方法，遍历并打印所有歌曲

**实验检查点**:
- [ ] `Playlist`类包含私有成员变量
- [ ] 构造函数能正确初始化对象
- [ ] 能成功添加歌曲到播放列表
- [ ] `listSongs()`能正确显示所有歌曲信息

**思考题**:
- 为什么`songs`要声明为`private`？
- 如果`songs`是`public`，会有什么风险？

---

### 实验4：集合类型的选择与性能测试

**实验目的**:
- 理解不同集合类型的特点
- 掌握`ArrayList`、`LinkedList`、`HashSet`的使用场景
- 学习性能测试的基本方法

**实验内容**:
1. 使用`ArrayList`实现`Playlist`
2. 实现`findSongByTitle`方法
3. 对比不同集合类型的性能
4. 处理集合操作的边界情况

**实验步骤**:
1. 在`Playlist`中使用`ArrayList<Song>`存储歌曲
2. 实现`findSongByTitle(String title)`方法
3. 实现`removeSong(int index)`方法
4. 添加边界检查：索引越界时抛出异常
5. 编写性能测试：比较`ArrayList`和`LinkedList`在开头插入元素的性能

**实验检查点**:
- [ ] `findSongByTitle`能正确查找歌曲
- [ ] `removeSong`能正确删除指定索引的歌曲
- [ ] 边界检查正常工作（索引<0或>=size时抛出异常）
- [ ] 理解为什么`ArrayList`适合当前场景

**扩展练习**:
- 如果要求播放列表不允许重复歌曲，应该使用什么集合？
- 实现`getTotalDuration()`方法，计算播放列表总时长

---

### 实验5：交互式命令行界面

**实验目的**:
- 掌握Java输入输出
- 学习事件循环和用户交互
- 理解异常处理机制

**实验内容**:
1. 实现主循环菜单
2. 使用`Scanner`读取用户输入
3. 使用`switch`语句分发命令
4. 处理输入异常

**实验步骤**:
1. 在`Main.java`中创建`while(true)`主循环
2. 打印菜单选项：
   ```
   1. 添加歌曲
   2. 查看列表
   3. 删除歌曲
   0. 退出
   ```
3. 使用`Scanner`读取用户输入
4. 使用`switch`语句处理不同选项
5. 添加`try-catch`处理`InputMismatchException`
6. 实现退出功能（输入0时`break`）

**实验检查点**:
- [ ] 菜单能正确显示和循环
- [ ] 能正确读取用户输入的数字选项
- [ ] 输入非数字时能捕获异常并提示用户
- [ ] 退出功能正常工作

**扩展练习**:
- 添加"搜索歌曲"功能
- 添加"显示播放列表统计信息"功能

---

## 第二部分：持久化与测试（实验6-10）

### 实验6：序列化与反序列化

**实验目的**:
- 理解序列化的概念
- 掌握CSV格式的读写
- 学习字符串解析

**实验内容**:
1. 为`Song`实现`toCsvString()`方法
2. 实现`fromCsvString()`静态方法
3. 为`Playlist`实现`saveToStrings()`和`loadFromStrings()`方法
4. 处理CSV解析异常

**实验步骤**:
1. 在`Song` record中添加`toCsvString()`方法：
   ```java
   public String toCsvString() {
       return title + "," + artist + "," + durationInSeconds;
   }
   ```
2. 实现静态方法`fromCsvString(String csv)`：
   ```java
   public static Song fromCsvString(String csv) {
       String[] parts = csv.split(",");
       return new Song(parts[0], parts[1], Integer.parseInt(parts[2]));
   }
   ```
3. 在`Playlist`中实现`saveToStrings()`返回`List<String>`
4. 实现`loadFromStrings(List<String> csvLines)`
5. 添加异常处理：处理格式错误的CSV行

**实验检查点**:
- [ ] `toCsvString()`和`fromCsvString()`能正确转换
- [ ] 转换后的对象与原对象相等（使用`equals()`）
- [ ] `Playlist`能正确保存和加载歌曲列表
- [ ] 格式错误的CSV能抛出有意义的异常

**思考题**:
- 如果歌曲标题包含逗号，当前实现会出什么问题？
- 如何改进CSV格式来处理这种情况？

---

### 实验7：文件I/O与持久化

**实验目的**:
- 掌握Java NIO.2文件操作
- 实现数据的持久化存储
- 学习资源管理

**实验内容**:
1. 使用`Files`类实现文件读写
2. 在程序启动时自动加载数据
3. 在程序退出时自动保存数据
4. 处理文件不存在的场景

**实验步骤**:
1. 在`Playlist`中添加`saveToFile(String filePath)`方法：
   ```java
   public void saveToFile(String filePath) throws IOException {
       List<String> lines = saveToStrings();
       Files.write(Path.of(filePath), lines, StandardCharsets.UTF_8);
   }
   ```
2. 实现`loadFromFile(String filePath)`方法
3. 在`Main`类的`main`方法开始处调用`loadFromFile`
4. 在用户选择退出时调用`saveToFile`
5. 使用`Files.exists()`检查文件是否存在

**实验检查点**:
- [ ] 程序启动时能加载之前保存的播放列表
- [ ] 程序退出时能保存当前播放列表
- [ ] 文件不存在时能创建新文件
- [ ] 文件读写操作有适当的异常处理

**扩展练习**:
- 添加文件大小检查（如果文件过大，给出警告）
- 实现备份功能（保存时同时创建`.bak`备份文件）

---

### 实验8：JUnit 5单元测试基础

**实验目的**:
- 理解单元测试的重要性
- 掌握JUnit 5的基本用法
- 学习测试驱动开发思想

**实验内容**:
1. 配置JUnit 5测试环境
2. 为`Playlist`类编写单元测试
3. 测试正常流程和边界情况
4. 理解测试金字塔模型

**实验步骤**:
1. 在`build.gradle.kts`中添加JUnit 5依赖：
   ```kotlin
   dependencies {
       testImplementation("org.junit.jupiter:junit-jupiter:5.9.2")
   }
   ```
2. 创建`src/test/java/com/vibevault/PlaylistTest.java`
3. 编写测试方法：
   ```java
   @Test
   void testAddSong() {
       Playlist playlist = new Playlist("我的歌单");
       Song song = new Song("夜曲", "周杰伦", 240);
       playlist.addSong(song);
       assertEquals(1, playlist.getSongCount());
   }
   ```
4. 测试边界情况：空列表、索引越界等

**实验检查点**:
- [ ] JUnit 5依赖配置正确
- [ ] 能运行测试并看到绿色通过标记
- [ ] 测试覆盖`addSong`、`removeSong`、`findSongByTitle`等方法
- [ ] 边界情况测试完善

**思考题**:
- 为什么单元测试要测试"正常情况"和"异常情况"？
- 测试代码应该比生产代码多吗？

---

### 实验9：AssertJ断言库与测试表达力

**实验目的**:
- 掌握AssertJ流畅的断言API
- 提高测试代码的可读性
- 学习更精确的断言方法

**实验内容**:
1. 引入AssertJ依赖
2. 使用AssertJ重写现有测试
3. 学习链式断言
4. 测试异常情况

**实验步骤**:
1. 添加AssertJ依赖：
   ```kotlin
   testImplementation("org.assertj:assertj-core:3.24.2")
   ```
2. 重写测试，使用`assertThat()`：
   ```java
   import static org.assertj.core.api.Assertions.*;
   
   @Test
   void testAddSong() {
       Playlist playlist = new Playlist("我的歌单");
       Song song = new Song("夜曲", "周杰伦", 240);
       
       playlist.addSong(song);
       
       assertThat(playlist.getSongCount()).isEqualTo(1);
       assertThat(playlist.listSongs()).contains(song);
   }
   ```
3. 使用`assertThatThrownBy()`测试异常

**实验检查点**:
- [ ] AssertJ依赖配置正确
- [ ] 所有测试改用AssertJ断言
- [ ] 测试代码更易读
- [ ] 异常测试使用`assertThatThrownBy()`

---

### 实验10：Mockito模拟与隔离测试

**实验目的**:
- 理解测试隔离的重要性
- 掌握Mockito的基本用法
- 学习依赖注入和接口设计

**实验内容**:
1. 引入Mockito依赖
2. 创建`PlaylistRepository`接口
3. 使用Mockito创建Mock对象
4. 编写隔离的Service层测试

**实验步骤**:
1. 添加Mockito依赖：
   ```kotlin
   testImplementation("org.mockito:mockito-core:5.3.1")
   testImplementation("org.mockito:mockito-junit-jupiter:5.3.1")
   ```
2. 创建`PlaylistRepository`接口：
   ```java
   public interface PlaylistRepository {
       void save(Playlist playlist) throws IOException;
       Playlist load() throws IOException;
   }
   ```
3. 创建`FilePlaylistRepository`实现
4. 创建`PlaylistService`，依赖`PlaylistRepository`接口
5. 编写测试，使用`@Mock`和`@InjectMocks`：
   ```java
   @ExtendWith(MockitoExtension.class)
   class PlaylistServiceTest {
       @Mock
       private PlaylistRepository repository;
       
       @InjectMocks
       private PlaylistService service;
       
       @Test
       void testAddSong() throws IOException {
           Playlist playlist = new Playlist("测试");
           when(repository.load()).thenReturn(playlist);
           
           service.addSongToPlaylist(new Song("测试", "测试", 100));
           
           verify(repository).save(any(Playlist.class));
       }
   }
   ```

**实验检查点**:
- [ ] Mockito依赖配置正确
- [ ] 能创建Mock对象并设置返回值
- [ ] 能验证方法调用（`verify()`）
- [ ] 测试不依赖真实文件系统

---

## 第三部分：架构与设计（实验11-15）

### 实验11：三层架构重构

**实验目的**:
- 理解分层架构的设计思想
- 掌握代码重构的技巧
- 学习关注点分离

**实验内容**:
1. 创建三层架构：Controller、Service、Repository
2. 将现有代码重构到对应层次
3. 实现依赖注入
4. 保持功能不变的前提下改善结构

**实验步骤**:
1. 创建包结构：
   - `com.vibevault.ui` (Controller层)
   - `com.vibevault.service` (Service层)
   - `com.vibevault.repository` (Repository层)
2. 创建`PlaylistController`，负责UI交互
3. 创建`PlaylistService`，包含业务逻辑
4. 创建`FilePlaylistRepository`，负责数据持久化
5. 重构`Main`类，使用新的三层架构
6. 运行所有测试，确保功能不变

**实验检查点**:
- [ ] 三层架构清晰分离
- [ ] 每层职责明确
- [ ] 通过接口解耦
- [ ] 所有原有功能正常工作
- [ ] 所有测试通过

**思考题**:
- 为什么Controller不直接调用Repository？
- 这种分层架构带来了什么好处？

---

### 实验12：Spring Boot项目初始化

**实验目的**:
- 理解Spring Boot的约定优于配置
- 掌握Spring Boot项目的创建
- 学习自动配置原理

**实验内容**:
1. 将Gradle项目改造为Spring Boot项目
2. 添加Spring Boot依赖
3. 创建主应用类
4. 配置application.properties

**实验步骤**:
1. 在`build.gradle.kts`中添加Spring Boot插件和依赖：
   ```kotlin
   plugins {
       id("org.springframework.boot") version "3.1.5"
       id("io.spring.dependency-management") version "1.1.3"
   }
   
   dependencies {
       implementation("org.springframework.boot:spring-boot-starter-web")
   }
   ```
2. 创建`VibeVaultApplication.java`：
   ```java
   @SpringBootApplication
   public class VibeVaultApplication {
       public static void main(String[] args) {
           SpringApplication.run(VibeVaultApplication.class, args);
       }
   }
   ```
3. 配置`application.properties`：
   ```properties
   server.port=8080
   spring.application.name=vibevault
   ```
4. 运行应用，验证启动成功

**实验检查点**:
- [ ] Spring Boot项目创建成功
- [ ] 应用能正常启动
- [ ] 能看到Spring Boot启动日志
- [ ] 端口配置生效

---

### 实验13：构建第一个REST API

**实验目的**:
- 掌握REST API的设计原则
- 学习Spring MVC注解
- 理解HTTP方法与资源操作的关系

**实验内容**:
1. 创建`PlaylistController` REST控制器
2. 实现`GET /api/playlists`端点
3. 实现`POST /api/playlists`端点
4. 使用Postman测试API

**实验步骤**:
1. 创建`PlaylistController`：
   ```java
   @RestController
   @RequestMapping("/api/playlists")
   public class PlaylistController {
       private final PlaylistService service;
       
       public PlaylistController(PlaylistService service) {
           this.service = service;
       }
       
       @GetMapping
       public List<Playlist> getAllPlaylists() {
           return service.getAllPlaylists();
       }
       
       @PostMapping
       public Playlist createPlaylist(@RequestBody CreatePlaylistRequest request) {
           return service.createPlaylist(request.name());
       }
   }
   ```
2. 创建DTO类（如`CreatePlaylistRequest`）
3. 使用Postman测试GET请求
4. 使用Postman测试POST请求

**实验检查点**:
- [ ] `@RestController`和`@RequestMapping`注解正确使用
- [ ] GET端点能返回播放列表数据
- [ ] POST端点能创建新播放列表
- [ ] 响应格式为JSON
- [ ] 能使用Postman成功测试API

**扩展练习**:
- 实现`GET /api/playlists/{id}`获取单个播放列表
- 实现`DELETE /api/playlists/{id}`删除播放列表

---

### 实验14：数据库迁移 - PostgreSQL配置

**实验目的**:
- 理解关系型数据库的优势
- 掌握Spring Data JPA的配置
- 学习实体映射

**实验内容**:
1. 安装并配置PostgreSQL
2. 添加Spring Data JPA依赖
3. 配置数据库连接
4. 创建JPA实体类

**实验步骤**:
1. 安装PostgreSQL（或使用Docker）
2. 创建数据库：`CREATE DATABASE vibevault;`
3. 添加依赖：
   ```kotlin
   implementation("org.springframework.boot:spring-boot-starter-data-jpa")
   implementation("org.postgresql:postgresql")
   ```
4. 配置`application.properties`：
   ```properties
   spring.datasource.url=jdbc:postgresql://localhost:5432/vibevault
   spring.datasource.username=postgres
   spring.datasource.password=yourpassword
   spring.jpa.hibernate.ddl-auto=update
   ```
5. 将`Song`和`Playlist`改为JPA实体：
   ```java
   @Entity
   public class Song {
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Long id;
       private String title;
       private String artist;
       private int durationInSeconds;
       // getters and setters
   }
   ```

**实验检查点**:
- [ ] PostgreSQL安装并运行
- [ ] 数据库连接配置正确
- [ ] 实体类正确映射到数据库表
- [ ] Spring Boot启动时自动创建表结构
- [ ] 能使用数据库客户端查看表结构

---

### 实验15：Spring Data JPA Repository

**实验目的**:
- 掌握Spring Data JPA的使用
- 理解Repository模式
- 学习派生查询方法

**实验内容**:
1. 创建JPA Repository接口
2. 使用Repository替代文件操作
3. 实现自定义查询方法
4. 测试数据持久化

**实验步骤**:
1. 创建`SongRepository`：
   ```java
   public interface SongRepository extends JpaRepository<Song, Long> {
       List<Song> findByTitleContaining(String title);
       List<Song> findByArtist(String artist);
   }
   ```
2. 创建`PlaylistRepository`
3. 修改`PlaylistService`，使用Repository替代文件操作
4. 测试CRUD操作
5. 验证数据持久化到数据库

**实验检查点**:
- [ ] Repository接口定义正确
- [ ] 能使用Repository进行CRUD操作
- [ ] 自定义查询方法正常工作
- [ ] 数据正确保存到数据库
- [ ] 重启应用后数据不丢失

**扩展练习**:
- 实现分页查询
- 实现按多个条件组合查询

---

## 第四部分：前端开发（实验16-18）

### 实验16：React项目初始化与组件基础

**实验目的**:
- 掌握React开发环境搭建
- 理解React组件和JSX语法
- 学习现代JavaScript特性

**实验内容**:
1. 使用Vite创建React项目
2. 创建第一个React组件
3. 学习JSX语法
4. 理解组件渲染

**实验步骤**:
1. 安装Node.js和npm
2. 使用Vite创建React项目：
   ```bash
   npm create vite@latest vibevault-frontend -- --template react
   cd vibevault-frontend
   npm install
   ```
3. 创建`PlaylistList.jsx`组件：
   ```jsx
   function PlaylistList() {
       return (
           <div>
               <h1>我的播放列表</h1>
               <ul>
                   <li>播放列表1</li>
                   <li>播放列表2</li>
               </ul>
           </div>
       );
   }
   
   export default PlaylistList;
   ```
4. 在`App.jsx`中使用该组件
5. 运行开发服务器：`npm run dev`

**实验检查点**:
- [ ] React项目创建成功
- [ ] 能运行开发服务器
- [ ] 组件能正确渲染
- [ ] 理解JSX语法
- [ ] 浏览器能显示组件内容

---

### 实验17：React Hooks与状态管理

**实验目的**:
- 理解React Hooks的概念
- 掌握`useState`和`useEffect`
- 学习组件状态管理

**实验内容**:
1. 使用`useState`管理组件状态
2. 使用`useEffect`处理副作用
3. 实现数据加载和显示
4. 处理加载状态和错误

**实验步骤**:
1. 创建带状态的组件：
   ```jsx
   import { useState, useEffect } from 'react';
   
   function PlaylistList() {
       const [playlists, setPlaylists] = useState([]);
       const [loading, setLoading] = useState(true);
       
       useEffect(() => {
           fetch('http://localhost:8080/api/playlists')
               .then(response => response.json())
               .then(data => {
                   setPlaylists(data);
                   setLoading(false);
               })
               .catch(error => {
                   console.error('Error:', error);
                   setLoading(false);
               });
       }, []);
       
       if (loading) return <div>加载中...</div>;
       
       return (
           <div>
               <h1>我的播放列表</h1>
               <ul>
                   {playlists.map(playlist => (
                       <li key={playlist.id}>{playlist.name}</li>
                   ))}
               </ul>
           </div>
       );
   }
   ```
2. 实现加载状态显示
3. 实现错误处理

**实验检查点**:
- [ ] `useState`正确使用
- [ ] `useEffect`正确使用
- [ ] 能从后端API获取数据
- [ ] 加载状态正确显示
- [ ] 错误情况有适当处理

---

### 实验18：前后端联调与CORS配置

**实验目的**:
- 掌握前后端分离开发
- 理解CORS跨域问题
- 学习API调用和错误处理

**实验内容**:
1. 配置Spring Boot CORS
2. 实现完整的CRUD操作前端
3. 处理API调用错误
4. 实现表单提交

**实验步骤**:
1. 在Spring Boot中配置CORS：
   ```java
   @Configuration
   public class CorsConfig {
       @Bean
       public CorsConfigurationSource corsConfigurationSource() {
           CorsConfiguration configuration = new CorsConfiguration();
           configuration.setAllowedOrigins(Arrays.asList("http://localhost:5173"));
           configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE"));
           configuration.setAllowedHeaders(Arrays.asList("*"));
           configuration.setAllowCredentials(true);
           
           UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
           source.registerCorsConfiguration("/**", configuration);
           return source;
       }
   }
   ```
2. 创建`PlaylistForm`组件，实现表单提交
3. 实现创建播放列表功能
4. 实现删除播放列表功能
5. 添加错误提示和成功提示

**实验检查点**:
- [ ] CORS配置正确，前端能调用后端API
- [ ] 能创建新的播放列表
- [ ] 能删除播放列表
- [ ] API调用错误有适当处理
- [ ] 表单验证正常工作

**扩展练习**:
- 实现编辑播放列表功能
- 添加确认对话框（删除前确认）

---

## 第五部分：安全与认证（实验19-21）

### 实验19：Spring Security基础配置

**实验目的**:
- 理解Spring Security的基本概念
- 掌握默认安全配置
- 学习安全配置的定制

**实验内容**:
1. 添加Spring Security依赖
2. 体验"默认安全"原则
3. 配置安全策略
4. 创建用户实体

**实验步骤**:
1. 添加Spring Security依赖：
   ```kotlin
   implementation("org.springframework.boot:spring-boot-starter-security")
   ```
2. 重启应用，观察所有API返回401/403错误
3. 创建`SecurityConfig`：
   ```java
   @Configuration
   @EnableWebSecurity
   public class SecurityConfig {
       @Bean
       public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
           http
               .authorizeHttpRequests(auth -> auth
                   .requestMatchers("/api/auth/**").permitAll()
                   .anyRequest().authenticated()
               )
               .csrf(csrf -> csrf.disable());
           return http.build();
       }
       
       @Bean
       public PasswordEncoder passwordEncoder() {
           return new BCryptPasswordEncoder();
       }
   }
   ```
4. 创建`User`实体类：
   ```java
   @Entity
   public class User {
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Long id;
       
       @Column(unique = true)
       private String username;
       
       private String password;
       
       // getters and setters
   }
   ```

**实验检查点**:
- [ ] Spring Security依赖添加成功
- [ ] 应用启动后API默认被保护
- [ ] 能配置安全策略
- [ ] `PasswordEncoder` Bean创建成功
- [ ] `User`实体类定义正确

**思考题**:
- 为什么Spring Security默认锁定所有端点？
- `BCryptPasswordEncoder`和`MD5`有什么区别？

---

### 实验20：用户认证API实现

**实验目的**:
- 实现用户注册功能
- 实现用户登录功能
- 学习密码加密存储
- 编写集成测试

**实验内容**:
1. 创建`UserRepository`
2. 实现注册API
3. 实现登录API
4. 编写集成测试

**实验步骤**:
1. 创建`UserRepository`：
   ```java
   public interface UserRepository extends JpaRepository<User, Long> {
       Optional<User> findByUsername(String username);
   }
   ```
2. 创建`AuthenticationService`：
   ```java
   @Service
   public class AuthenticationService {
       private final UserRepository userRepository;
       private final PasswordEncoder passwordEncoder;
       
       public AuthenticationService(UserRepository userRepository, 
                                   PasswordEncoder passwordEncoder) {
           this.userRepository = userRepository;
           this.passwordEncoder = passwordEncoder;
       }
       
       public User signup(String username, String password) {
           if (userRepository.findByUsername(username).isPresent()) {
               throw new RuntimeException("用户名已存在");
           }
           
           User user = new User();
           user.setUsername(username);
           user.setPassword(passwordEncoder.encode(password));
           return userRepository.save(user);
       }
       
       public User signin(String username, String password) {
           User user = userRepository.findByUsername(username)
               .orElseThrow(() -> new RuntimeException("用户名或密码错误"));
           
           if (!passwordEncoder.matches(password, user.getPassword())) {
               throw new RuntimeException("用户名或密码错误");
           }
           
           return user;
       }
   }
   ```
3. 创建`AuthenticationController`：
   ```java
   @RestController
   @RequestMapping("/api/auth")
   public class AuthenticationController {
       private final AuthenticationService service;
       
       @PostMapping("/signup")
       public ResponseEntity<?> signup(@RequestBody SignupRequest request) {
           try {
               User user = service.signup(request.username(), request.password());
               return ResponseEntity.ok(Map.of("message", "注册成功", "userId", user.getId()));
           } catch (RuntimeException e) {
               return ResponseEntity.badRequest().body(Map.of("error", e.getMessage()));
           }
       }
       
       @PostMapping("/signin")
       public ResponseEntity<?> signin(@RequestBody SigninRequest request) {
           try {
               User user = service.signin(request.username(), request.password());
               return ResponseEntity.ok(Map.of("message", "登录成功", "userId", user.getId()));
           } catch (RuntimeException e) {
               return ResponseEntity.status(401).body(Map.of("error", e.getMessage()));
           }
       }
   }
   ```
4. 编写集成测试：
   ```java
   @SpringBootTest
   @AutoConfigureMockMvc
   class AuthenticationControllerTest {
       @Autowired
       private MockMvc mockMvc;
       
       @Autowired
       private UserRepository userRepository;
       
       @Test
       void testSignup() throws Exception {
           mockMvc.perform(post("/api/auth/signup")
                   .contentType(MediaType.APPLICATION_JSON)
                   .content("{\"username\":\"testuser\",\"password\":\"testpass\"}"))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.message").value("注册成功"));
       }
   }
   ```

**实验检查点**:
- [ ] 能成功注册新用户
- [ ] 密码以加密形式存储（BCrypt哈希）
- [ ] 能成功登录
- [ ] 错误密码登录失败
- [ ] 集成测试通过

**扩展练习**:
- 添加用户名唯一性验证
- 添加密码强度验证（至少8位，包含字母和数字）

---

### 实验21：JWT认证实现

**实验目的**:
- 理解JWT的工作原理
- 实现JWT的生成和验证
- 配置JWT过滤器
- 实现无状态认证

**实验内容**:
1. 引入JWT库
2. 创建JWT服务
3. 实现JWT过滤器
4. 配置Spring Security使用JWT

**实验步骤**:
1. 添加JWT依赖：
   ```kotlin
   implementation("io.jsonwebtoken:jjwt-api:0.11.5")
   runtimeOnly("io.jsonwebtoken:jjwt-impl:0.11.5")
   runtimeOnly("io.jsonwebtoken:jjwt-jackson:0.11.5")
   ```
2. 配置JWT密钥（`application.properties`）：
   ```properties
   jwt.secret=your-secret-key-here-make-it-long-and-random
   jwt.expiration=86400000
   ```
3. 创建`JwtService`：
   ```java
   @Service
   public class JwtService {
       @Value("${jwt.secret}")
       private String secret;
       
       @Value("${jwt.expiration}")
       private long expiration;
       
       public String generateToken(String username) {
           return Jwts.builder()
               .setSubject(username)
               .setIssuedAt(new Date())
               .setExpiration(new Date(System.currentTimeMillis() + expiration))
               .signWith(SignatureAlgorithm.HS256, secret)
               .compact();
       }
       
       public String extractUsername(String token) {
           return Jwts.parser()
               .setSigningKey(secret)
               .parseClaimsJws(token)
               .getBody()
               .getSubject();
       }
       
       public boolean validateToken(String token) {
           try {
               Jwts.parser().setSigningKey(secret).parseClaimsJws(token);
               return true;
           } catch (JwtException | IllegalArgumentException e) {
               return false;
           }
       }
   }
   ```
4. 修改`AuthenticationService`，登录成功后返回JWT：
   ```java
   public Map<String, String> signin(String username, String password) {
       User user = signin(username, password);
       String token = jwtService.generateToken(user.getUsername());
       return Map.of("token", token, "username", user.getUsername());
   }
   ```
5. 创建`JwtAuthenticationFilter`：
   ```java
   public class JwtAuthenticationFilter extends OncePerRequestFilter {
       @Autowired
       private JwtService jwtService;
       
       @Autowired
       private UserRepository userRepository;
       
       @Override
       protected void doFilterInternal(HttpServletRequest request, 
                                       HttpServletResponse response, 
                                       FilterChain filterChain) throws ServletException, IOException {
           String authHeader = request.getHeader("Authorization");
           
           if (authHeader != null && authHeader.startsWith("Bearer ")) {
               String token = authHeader.substring(7);
               
               if (jwtService.validateToken(token)) {
                   String username = jwtService.extractUsername(token);
                   User user = userRepository.findByUsername(username).orElse(null);
                   
                   if (user != null) {
                       UsernamePasswordAuthenticationToken authentication = 
                           new UsernamePasswordAuthenticationToken(user, null, 
                               user.getAuthorities());
                       SecurityContextHolder.getContext().setAuthentication(authentication);
                   }
               }
           }
           
           filterChain.doFilter(request, response);
       }
   }
   ```
6. 在`SecurityConfig`中配置过滤器：
   ```java
   @Bean
   public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
       http
           .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
           .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
           // ... 其他配置
   }
   ```

**实验检查点**:
- [ ] JWT依赖配置正确
- [ ] 能生成JWT Token
- [ ] 能解析和验证JWT Token
- [ ] 登录API返回JWT
- [ ] 使用JWT能访问受保护端点
- [ ] 无效JWT被拒绝

**扩展练习**:
- 实现Token刷新机制
- 在前端存储和使用JWT

---

## 第六部分：授权与部署（实验22-24）

### 实验22：基于角色的访问控制

**实验目的**:
- 理解授权与认证的区别
- 实现资源所有权检查
- 使用`@PreAuthorize`注解
- 建立用户与资源关联

**实验内容**:
1. 重构Playlist实体，添加用户关联
2. 实现所有权检查
3. 使用`@PreAuthorize`实现声明式授权
4. 测试授权功能

**实验步骤**:
1. 重构`Playlist`实体，添加用户关联：
   ```java
   @Entity
   public class Playlist {
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Long id;
       
       private String name;
       
       @ManyToOne
       @JoinColumn(name = "user_id")
       private User owner;
       
       @OneToMany(mappedBy = "playlist", cascade = CascadeType.ALL)
       private List<Song> songs;
       
       // getters and setters
   }
   ```
2. 修改`PlaylistService`，创建播放列表时关联当前用户：
   ```java
   public Playlist createPlaylist(String name, User currentUser) {
       Playlist playlist = new Playlist();
       playlist.setName(name);
       playlist.setOwner(currentUser);
       return playlistRepository.save(playlist);
   }
   ```
3. 创建`SecurityUtils`获取当前用户：
   ```java
   @Component
   public class SecurityUtils {
       public User getCurrentUser() {
           Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
           if (authentication != null && authentication.getPrincipal() instanceof User) {
               return (User) authentication.getPrincipal();
           }
           return null;
       }
   }
   ```
4. 在`SecurityConfig`中启用方法安全：
   ```java
   @EnableMethodSecurity
   public class SecurityConfig {
       // ...
   }
   ```
5. 创建`PlaylistSecurityService`：
   ```java
   @Service
   public class PlaylistSecurityService {
       public boolean isOwner(Long playlistId, User user) {
           Playlist playlist = playlistRepository.findById(playlistId)
               .orElseThrow(() -> new RuntimeException("播放列表不存在"));
           return playlist.getOwner().getId().equals(user.getId());
       }
   }
   ```
6. 在Controller中使用`@PreAuthorize`：
   ```java
   @DeleteMapping("/{id}")
   @PreAuthorize("@playlistSecurityService.isOwner(#id, authentication.principal)")
   public ResponseEntity<?> deletePlaylist(@PathVariable Long id) {
       playlistService.deletePlaylist(id);
       return ResponseEntity.ok().build();
   }
   ```

**实验检查点**:
- [ ] `Playlist`与`User`关联正确
- [ ] 创建播放列表时自动关联当前用户
- [ ] 能获取当前登录用户
- [ ] `@PreAuthorize`注解正常工作
- [ ] 用户A无法删除用户B的播放列表（返回403）
- [ ] 用户A能删除自己的播放列表

**扩展练习**:
- 实现"共享播放列表"功能（多用户访问）
- 添加角色权限（管理员可以删除任何播放列表）

---

### 实验23：Docker容器化

**实验目的**:
- 理解容器化的概念
- 掌握Dockerfile编写
- 学习Docker Compose编排
- 实现应用容器化部署

**实验内容**:
1. 编写Dockerfile
2. 构建Docker镜像
3. 编写docker-compose.yml
4. 使用Docker Compose启动应用

**实验步骤**:
1. 创建`Dockerfile`（多阶段构建）：
   ```dockerfile
   # 构建阶段
   FROM gradle:8.5-jdk21 AS build
   WORKDIR /app
   COPY build.gradle.kts settings.gradle.kts ./
   COPY gradle ./gradle
   COPY src ./src
   RUN gradle build --no-daemon -x test
   
   # 运行阶段
   FROM openjdk:21-jre-slim
   WORKDIR /app
   COPY --from=build /app/build/libs/*.jar app.jar
   EXPOSE 8080
   ENTRYPOINT ["java", "-jar", "app.jar"]
   ```
2. 创建`.dockerignore`：
   ```
   .gradle
   build
   .git
   .idea
   *.iml
   ```
3. 构建镜像：
   ```bash
   docker build -t vibevault-backend .
   ```
4. 创建`docker-compose.yml`：
   ```yaml
   version: '3.8'
   
   services:
     postgres:
       image: postgres:15
       environment:
         POSTGRES_DB: vibevault
         POSTGRES_USER: postgres
         POSTGRES_PASSWORD: postgres
       ports:
         - "5432:5432"
       volumes:
         - postgres_data:/var/lib/postgresql/data
     
     backend:
       build: .
       ports:
         - "8080:8080"
       environment:
         SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/vibevault
         SPRING_DATASOURCE_USERNAME: postgres
         SPRING_DATASOURCE_PASSWORD: postgres
       depends_on:
         - postgres
   
   volumes:
     postgres_data:
   ```
5. 启动服务：
   ```bash
   docker-compose up -d
   ```
6. 查看日志：
   ```bash
   docker-compose logs -f
   ```

**实验检查点**:
- [ ] Dockerfile编写正确
- [ ] 能成功构建Docker镜像
- [ ] `docker-compose.yml`配置正确
- [ ] 能使用`docker-compose up`启动服务
- [ ] 后端服务能连接数据库
- [ ] API能正常访问

**扩展练习**:
- 为前端应用创建Dockerfile
- 使用Nginx作为反向代理
- 配置环境变量文件（`.env`）

---

### 实验24：云平台部署与CI/CD

**实验目的**:
- 理解云平台部署流程
- 掌握基本的CI/CD概念
- 实现应用的云端部署
- 学习生产环境配置

**实验内容**:
1. 选择云平台（如DigitalOcean、阿里云、腾讯云）
2. 配置生产环境
3. 部署应用
4. 配置域名和HTTPS（可选）

**实验步骤**:
1. 创建云服务器实例（推荐配置：2核4G，Ubuntu 22.04）
2. 在服务器上安装Docker和Docker Compose：
   ```bash
   # 安装Docker
   curl -fsSL https://get.docker.com -o get-docker.sh
   sh get-docker.sh
   
   # 安装Docker Compose
   sudo apt-get update
   sudo apt-get install docker-compose-plugin
   ```
3. 配置生产环境`application-prod.properties`：
   ```properties
   spring.datasource.url=jdbc:postgresql://postgres:5432/vibevault
   spring.datasource.username=${DB_USERNAME}
   spring.datasource.password=${DB_PASSWORD}
   spring.jpa.hibernate.ddl-auto=validate
   spring.jpa.show-sql=false
   logging.level.root=INFO
   ```
4. 修改`docker-compose.yml`，添加生产环境配置
5. 使用Git将代码推送到服务器（或使用CI/CD）：
   ```bash
   # 在服务器上克隆项目
   git clone <your-repo-url>
   cd VibeVault-Book/chapter-code/ch10
   
   # 构建并启动
   docker-compose -f docker-compose.prod.yml up -d --build
   ```
6. 配置防火墙规则（开放8080端口）
7. 测试API访问：`http://your-server-ip:8080/api/playlists`

**实验检查点**:
- [ ] 云服务器创建成功
- [ ] Docker和Docker Compose安装成功
- [ ] 应用能成功部署
- [ ] 数据库连接正常
- [ ] API能从外网访问
- [ ] 应用日志正常

**CI/CD扩展（可选）**:
1. 创建GitHub Actions工作流（`.github/workflows/deploy.yml`）：
   ```yaml
   name: Deploy to Production
   
   on:
     push:
       branches: [ main ]
   
   jobs:
     deploy:
       runs-on: ubuntu-latest
       steps:
         - uses: actions/checkout@v3
         - name: Deploy to server
           uses: appleboy/ssh-action@master
           with:
             host: ${{ secrets.HOST }}
             username: ${{ secrets.USERNAME }}
             key: ${{ secrets.SSH_KEY }}
             script: |
               cd /path/to/project
               git pull
               docker-compose up -d --build
   ```

**实验报告要求**:
- 记录部署过程中遇到的问题
- 截图展示部署成功的界面
- 思考：生产环境和开发环境有什么区别？
- 总结整个24次实验的学习心得

---

## 实验总结

### 实验完成清单

**第一部分：基础入门（实验1-5）**
- [ ] 实验1：开发环境搭建与项目初始化
- [ ] 实验2：定义第一个数据模型 - Song Record
- [ ] 实验3：封装与类设计 - Playlist类
- [ ] 实验4：集合类型的选择与性能测试
- [ ] 实验5：交互式命令行界面

**第二部分：持久化与测试（实验6-10）**
- [ ] 实验6：序列化与反序列化
- [ ] 实验7：文件I/O与持久化
- [ ] 实验8：JUnit 5单元测试基础
- [ ] 实验9：AssertJ断言库与测试表达力
- [ ] 实验10：Mockito模拟与隔离测试

**第三部分：架构与设计（实验11-15）**
- [ ] 实验11：三层架构重构
- [ ] 实验12：Spring Boot项目初始化
- [ ] 实验13：构建第一个REST API
- [ ] 实验14：数据库迁移 - PostgreSQL配置
- [ ] 实验15：Spring Data JPA Repository

**第四部分：前端开发（实验16-18）**
- [ ] 实验16：React项目初始化与组件基础
- [ ] 实验17：React Hooks与状态管理
- [ ] 实验18：前后端联调与CORS配置

**第五部分：安全与认证（实验19-21）**
- [ ] 实验19：Spring Security基础配置
- [ ] 实验20：用户认证API实现
- [ ] 实验21：JWT认证实现

**第六部分：授权与部署（实验22-24）**
- [ ] 实验22：基于角色的访问控制
- [ ] 实验23：Docker容器化
- [ ] 实验24：云平台部署与CI/CD

---

## 实验评分标准

### 每次实验评分细则

| 评分项 | 分值 | 评分标准 |
|--------|------|----------|
| 代码正确性 | 40分 | 功能实现完整，无编译错误，能正常运行 |
| 代码质量 | 20分 | 代码规范、命名清晰、结构合理、注释适当 |
| 实验报告 | 20分 | 报告完整、步骤清晰、问题分析深入 |
| 创新性思考 | 20分 | 完成扩展练习、提出改进方案、深入思考 |

### 总分计算

- 每次实验满分：100分
- 24次实验总分：2400分
- 最终成绩 = 总分 / 24

### 加分项

- 完成所有扩展练习：+5分/次
- 提出有价值的问题或建议：+2分/次
- 帮助其他同学解决问题：+3分/次
- 代码提交到GitHub并持续维护：+10分

---

## 实验资源

### 推荐工具
- **IDE**: VS Code / IntelliJ IDEA
- **AI助手**: Cursor / GitHub Copilot / ChatGPT
- **API测试**: Postman / Insomnia
- **数据库管理**: DBeaver / pgAdmin
- **版本控制**: Git / GitHub
- **容器**: Docker Desktop

### 学习资源
- [Java 21官方文档](https://docs.oracle.com/en/java/javase/21/)
- [Spring Boot官方文档](https://spring.io/projects/spring-boot)
- [React官方文档](https://react.dev/)
- [Docker官方文档](https://docs.docker.com/)

### 实验代码仓库
- 建议每个实验创建独立的Git分支
- 提交代码时使用清晰的commit message
- 定期push到远程仓库

---

## 实验注意事项

1. **时间管理**: 每次实验建议在2-3小时内完成，如遇困难及时寻求帮助
2. **代码备份**: 每次实验前备份代码，避免数据丢失
3. **文档记录**: 及时记录实验过程和遇到的问题
4. **代码规范**: 遵循Java编码规范，保持代码整洁
5. **测试驱动**: 编写代码前先思考测试用例
6. **AI协作**: 合理使用AI辅助，但必须理解每行代码
7. **版本控制**: 使用Git管理代码，提交有意义的commit

---

**祝实验顺利！**

*如有问题，请及时联系授课教师或通过课程讨论区提问。*